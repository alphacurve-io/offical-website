<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alphacurve.io Meeting Room</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: #f0f0f0;
        }

        canvas {
            display: block;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #333;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        #info h3 {
            margin: 0 0 10px 0;
            color: #1a73e8;
        }
    </style>
</head>
<body>
    <!-- <div id="info">
        <h3>ğŸ§± Alphacurve.io Meeting Room</h3>
        <p>Drag mouse to rotate view</p>
        <p>Scroll wheel to zoom</p>
    </div> -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // å¾ URL åƒæ•¸è®€å–è‡ªè¨‚äººç‰©è¨­å®šï¼ˆç”± React å‚³å…¥ï¼‰
        // people = encodeURIComponent(JSON.stringify([{ bodyColor, hairColor, expression }, ...]))
        function getCustomPeopleConfigs() {
            try {
                const params = new URLSearchParams(window.location.search);
                const raw = params.get('people');
                if (!raw) return null;
                const decoded = decodeURIComponent(raw);
                const parsed = JSON.parse(decoded);
                if (!Array.isArray(parsed)) return null;
                return parsed;
            } catch (e) {
                console.warn('Failed to parse custom people config:', e);
                return null;
            }
        }

        // å¾ URL è®€å–ç™½æ¿æ¨™é¡Œï¼ˆç”± React å‚³å…¥ï¼‰
        function getBoardTitle() {
            try {
                const params = new URLSearchParams(window.location.search);
                const raw = params.get('title');
                if (!raw) return null;
                return decodeURIComponent(raw);
            } catch (e) {
                console.warn('Failed to parse board title:', e);
                return null;
            }
        }

        // å¾ URL è®€å–æ–‡æœ¬å…§å®¹ï¼ˆç”± React å‚³å…¥ï¼‰
        function getTextContent() {
            try {
                const params = new URLSearchParams(window.location.search);
                const raw = params.get('textContent');
                if (!raw) return null;
                const decoded = decodeURIComponent(raw);
                return JSON.parse(decoded);
            } catch (e) {
                console.warn('Failed to parse text content:', e);
                // è¿”å›é»˜èªæ–‡æœ¬
                return {
                    chatPrompt: 'ä½ æœ‰ä»€éº¼å•é¡Œæƒ³å•å—ï¼Ÿ',
                    inputPlaceholder: 'è¼¸å…¥ä½ çš„å•é¡Œ...',
                    sendButton: 'ç™¼é€',
                    loadingText: 'æ€è€ƒä¸­...',
                    errorText: 'æŠ±æ­‰ï¼Œç™¼ç”ŸéŒ¯èª¤ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚'
                };
            }
        }

        function hexToColorNumber(hex, fallback) {
            if (!hex || typeof hex !== 'string') return fallback;
            const cleaned = hex.replace('#', '');
            const num = parseInt(cleaned, 16);
            return Number.isNaN(num) ? fallback : num;
        }

        // å ´æ™¯è¨­ç½®
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);

        // ç›¸æ©Ÿ
        const camera = new THREE.PerspectiveCamera(
            45,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 8, 15);
        camera.lookAt(0, 0, 0);

        // æ¸²æŸ“å™¨
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // å…‰æº
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -10;
        directionalLight.shadow.camera.right = 10;
        directionalLight.shadow.camera.top = 10;
        directionalLight.shadow.camera.bottom = -10;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // åœ°æ¿
        const floorGeometry = new THREE.PlaneGeometry(30, 30);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xe0e0e0,
            roughness: 0.8,
            metalness: 0.2
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -0.5;
        floor.receiveShadow = true;
        scene.add(floor);

        // å‰µå»ºæœ¨ç´‹ç´‹ç†
        function createWoodTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // åŸºç¤æœ¨è‰²
            ctx.fillStyle = '#8B6F47';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // æœ¨ç´‹æ¢ç´‹æ•ˆæœ
            for (let i = 0; i < canvas.width; i += 2) {
                const noise = Math.sin(i * 0.05) * 3;
                const brightness = 50 + Math.sin(i * 0.1) * 20;
                ctx.fillStyle = `rgba(${139 + brightness}, ${111 + brightness * 0.7}, ${71 + brightness * 0.5}, 0.3)`;
                ctx.fillRect(i, 0, 2, canvas.height);
            }

            // æ·»åŠ æœ¨ç´‹ç´°ç¯€
            for (let i = 0; i < 50; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const w = 1 + Math.random() * 2;
                const h = canvas.height;
                const alpha = 0.1 + Math.random() * 0.2;
                ctx.fillStyle = `rgba(${100 + Math.random() * 50}, ${80 + Math.random() * 40}, ${50 + Math.random() * 30}, ${alpha})`;
                ctx.fillRect(x, y, w, h);
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(2, 1); // æ©«å‘é‡è¤‡ï¼Œè®“æœ¨ç´‹æ›´è‡ªç„¶
            return texture;
        }

        // å‰µå»ºæœƒè­°æ¡Œ
        function createTable() {
            const table = new THREE.Group();

            // æ¡Œé¢ - ä½¿ç”¨æœ¨ç´‹æè³ª
            const topGeometry = new THREE.BoxGeometry(6, 0.2, 4);
            const woodTexture = createWoodTexture();
            const topMaterial = new THREE.MeshStandardMaterial({ 
                map: woodTexture,
                roughness: 0.7,
                metalness: 0.1
            });
            const top = new THREE.Mesh(topGeometry, topMaterial);
            top.position.y = 1;
            top.castShadow = true;
            top.receiveShadow = true;
            table.add(top);

            // æ¡Œè…³
            const legGeometry = new THREE.BoxGeometry(0.15, 1, 0.15);
            const legMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xcccccc,
                roughness: 0.5
            });

            const legPositions = [
                [-2.5, 0.5, -1.5],
                [2.5, 0.5, -1.5],
                [-2.5, 0.5, 1.5],
                [2.5, 0.5, 1.5]
            ];

            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                leg.position.set(...pos);
                leg.castShadow = true;
                table.add(leg);
            });

            // æ¡Œä¸Šç‰©å“ - ç­†è¨˜å‹é›»è…¦
            const laptopBase = new THREE.BoxGeometry(0.6, 0.05, 0.4);
            const laptopScreen = new THREE.BoxGeometry(0.6, 0.5, 0.05);
            const laptopMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            
            const laptop = new THREE.Group();
            const base = new THREE.Mesh(laptopBase, laptopMaterial);
            base.position.y = 1.15;
            const screen = new THREE.Mesh(laptopScreen, laptopMaterial);
            screen.position.set(0, 1.4, -0.15);
            screen.rotation.x = -0.3;
            laptop.add(base, screen);
            laptop.position.set(-1.5, 0, 0);
            table.add(laptop);

            // æ–‡ä»¶
            const docGeometry = new THREE.BoxGeometry(0.3, 0.02, 0.4);
            const docMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const document = new THREE.Mesh(docGeometry, docMaterial);
            document.position.set(1.5, 1.12, 0.5);
            table.add(document);

            // æ‰‹æ©Ÿ
            const phoneGeometry = new THREE.BoxGeometry(0.15, 0.02, 0.25);
            const phoneMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const phone = new THREE.Mesh(phoneGeometry, phoneMaterial);
            phone.position.set(0.8, 1.12, -0.8);
            table.add(phone);

            return table;
        }

        // å‰µå»ºæ¨‚é«˜äººç‰©
        // expression: 'neutral' | 'smile' | 'sad' | 'surprised'
        function createLegoPerson(bodyColor, hairColor, expression = 'neutral') {
            const person = new THREE.Group();

            // èº«é«”
            const bodyGeometry = new THREE.BoxGeometry(0.8, 1.2, 0.6);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: bodyColor,
                roughness: 0.4
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.6;
            body.castShadow = true;
            person.add(body);

            // é ­éƒ¨
            const headGeometry = new THREE.BoxGeometry(0.7, 0.8, 0.7);
            const headMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffd700,
                roughness: 0.3
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.5;
            head.castShadow = true;
            person.add(head);

            // é ­é«®
            const hairGeometry = new THREE.BoxGeometry(0.72, 0.3, 0.72);
            const hairMaterial = new THREE.MeshStandardMaterial({ 
                color: hairColor,
                roughness: 0.6
            });
            const hair = new THREE.Mesh(hairGeometry, hairMaterial);
            hair.position.y = 2.05;
            hair.castShadow = true;
            person.add(hair);

            // çœ¼ç›å®¹å™¨
            const eyesGroup = new THREE.Group();
            eyesGroup.position.set(0, 1.6, 0.36);

            // å·¦çœ¼
            const leftEye = createEye();
            leftEye.position.x = -0.2;
            eyesGroup.add(leftEye);

            // å³çœ¼
            const rightEye = createEye();
            rightEye.position.x = 0.2;
            eyesGroup.add(rightEye);

            person.add(eyesGroup);
            person.userData.eyes = [leftEye, rightEye];

            // å˜´å·´ï¼ˆè¡¨æƒ…ï¼‰
            let mouth;
            if (expression === 'surprised') {
                // é©šè¨ï¼šåœ“å½¢å˜´å·´
                const mouthGeometry = new THREE.CircleGeometry(0.11, 28);
                const mouthMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x000000,
                    side: THREE.DoubleSide
                });
                mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
                mouth.position.set(0, 1.34, 0.37);
            } else if (expression === 'smile') {
                // ç¬‘è‡‰ï¼šä½¿ç”¨å¼§å½¢ Shape å¹¾ä½•åšå‡ºçœŸæ­£çš„å¾®ç¬‘æ›²ç·š
                const width = 0.6;
                const height = 0.16;
                const thickness = 0.05;

                const smileShape = new THREE.Shape();
                // å¤–å¼§ç·šï¼ˆå¾€ä¸‹å½ï¼‰
                smileShape.moveTo(-width / 2, 0);
                smileShape.quadraticCurveTo(0, -height, width / 2, 0);
                // å…§å¼§ç·šï¼ˆå¾€ä¸‹å½ï¼Œç¨å¾®é ä¸Šå½¢æˆå¼§å½¢æ¢å¸¶ï¼‰
                const innerOffset = 0.04;
                smileShape.lineTo(width / 2, innerOffset);
                smileShape.quadraticCurveTo(0, -height + innerOffset, -width / 2, innerOffset);
                smileShape.closePath();

                const mouthGeometry = new THREE.ShapeGeometry(smileShape, 24);
                const mouthMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff4444,
                    emissive: 0x330000,
                    emissiveIntensity: 0.4
                });
                mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
                mouth.position.set(0, 1.36, 0.36 + thickness / 2);
            } else if (expression === 'sad') {
                // é›£éï¼šæ¯”è¼ƒçŸ­ã€ç•¥é«˜ã€é¡è‰²åæ·±
                const mouthGeometry = new THREE.BoxGeometry(0.28, 0.05, 0.05);
                const mouthMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x111111
                });
                mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
                mouth.position.set(0, 1.49, 0.36);
            } else {
                // ä¸­æ€§è¡¨æƒ…
                const mouthGeometry = new THREE.BoxGeometry(0.35, 0.05, 0.05);
                const mouthMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x000000
                });
                mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
                mouth.position.set(0, 1.41, 0.36);
            }
            person.add(mouth);

            // æ‰‹è‡‚
            const armGeometry = new THREE.BoxGeometry(0.2, 0.8, 0.2);
            const armMaterial = new THREE.MeshStandardMaterial({ 
                color: bodyColor,
                roughness: 0.4
            });

            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.5, 0.8, 0);
            leftArm.rotation.z = 0.3;
            leftArm.castShadow = true;
            person.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.5, 0.8, 0);
            rightArm.rotation.z = -0.3;
            rightArm.castShadow = true;
            person.add(rightArm);

            // å­˜å‚¨æ‰‹è‡‚å¼•ç”¨ä»¥ä¾¿åŠ¨ç”»
            person.userData.leftArm = leftArm;
            person.userData.rightArm = rightArm;
            person.userData.armAnimation = {
                leftArm: 'none', // 'none', 'raise', 'point', 'spread'
                rightArm: 'none', // 'none', 'raise', 'point', 'spread'
                time: 0
            };

            return person;
        }

        // å‰µå»ºçœ¼ç›
        function createEye() {
            const eyeGroup = new THREE.Group();

            // çœ¼ç™½
            const whiteGeometry = new THREE.CircleGeometry(0.12, 16);
            const whiteMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffffff,
                side: THREE.DoubleSide
            });
            const white = new THREE.Mesh(whiteGeometry, whiteMaterial);
            eyeGroup.add(white);

            // çœ¼ç ï¼ˆå¯ç§»å‹•ï¼‰
            const pupilGeometry = new THREE.CircleGeometry(0.05, 16);
            const pupilMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x000000,
                side: THREE.DoubleSide
            });
            const pupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            pupil.position.z = 0.01;
            eyeGroup.add(pupil);

            eyeGroup.userData.pupil = pupil;

            return eyeGroup;
        }

        // æ·»åŠ æœƒè­°æ¡Œ
        const table = createTable();
        scene.add(table);

        // æ·»åŠ äººç‰©
        const people = [];

        const defaultPersonConfigs = [
            // æ­£é¢ä¸‰äºº
            { pos: [-3, 0, -3], rot: 0.5, body: 0x2c5f2d, hair: 0x654321, expression: 'smile', leftArm: 'raise', rightArm: 'raise' },
            { pos: [0, 0, -3], rot: 0, body: 0x1e3a5f, hair: 0xffd700, expression: 'surprised', leftArm: 'spread', rightArm: 'spread' },
            { pos: [3, 0, -3], rot: -0.5, body: 0x1a1a4e, hair: 0x8b4513, expression: 'neutral', leftArm: 'none', rightArm: 'point' },
            // èƒŒé¢ä¸‰äºº
            { pos: [-3, 0, 3], rot: 2.6, body: 0x1a1a4e, hair: 0x8b4513, expression: 'sad', leftArm: 'raise', rightArm: 'none' },
            { pos: [0, 0, 3], rot: Math.PI, body: 0x2c5f2d, hair: 0xffa500, expression: 'smile', leftArm: 'spread', rightArm: 'raise' },
            { pos: [3, 0, 3], rot: -2.6, body: 0x1e3a5f, hair: 0x654321, expression: 'neutral', leftArm: 'point', rightArm: 'spread' }
        ];

        const externalPeople = getCustomPeopleConfigs();

        const personConfigs = defaultPersonConfigs.map((cfg, index) => {
            const override = externalPeople && externalPeople[index] ? externalPeople[index] : {};
            return {
                ...cfg,
                body: hexToColorNumber(override.bodyColor, cfg.body),
                hair: hexToColorNumber(override.hairColor, cfg.hair),
                expression: override.expression || cfg.expression,
                messages: Array.isArray(override.messages) ? override.messages : (cfg.messages || []),
                leftArm: override.leftArm || cfg.leftArm || 'none',
                rightArm: override.rightArm || cfg.rightArm || 'none',
            };
        });

        personConfigs.forEach((config, index) => {
            const person = createLegoPerson(config.body, config.hair, config.expression);
            person.position.set(...config.pos);
            person.rotation.y = config.rot;
            person.userData.messages = config.messages || [];
            // è®¾ç½®å·¦å³æ‰‹åŠ¨ç”»ç±»å‹ï¼Œæ¯ä¸ªäººç‰©æœ‰ä¸åŒçš„åŠ¨ç”»å»¶è¿Ÿ
            person.userData.armAnimation.leftArm = config.leftArm || 'none';
            person.userData.armAnimation.rightArm = config.rightArm || 'none';
            // ä¸ºæ¯ä¸ªäººç‰©è®¾ç½®ä¸åŒçš„æ—¶é—´åç§»ï¼Œé¿å…æ‰€æœ‰äººåŒæ—¶åŠ¨ä½œ
            // æ¯ä¸ªäººç‰©åç§» 1/6 çš„å‘¨æœŸï¼ˆçº¦ 667msï¼‰ï¼Œè¿™æ ·6ä¸ªäººç‰©çš„åŠ¨ä½œä¼šå®Œå…¨é”™å¼€
            const cycleDuration = 4000;
            person.userData.armAnimation.time = (index / personConfigs.length) * cycleDuration;
            scene.add(person);
            people.push(person);
        });

        // ç‰†å£èˆ‡ç™½æ¿
        function createWalls() {
            const walls = new THREE.Group();

            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffffff,
                roughness: 0.6
            });

            // åƒ…ä¿ç•™å¾Œæ–¹é€™é¢ç‰†ï¼ˆå…¶ä»–å´ç‰†ç§»é™¤ï¼‰
            const backWallGeometry = new THREE.BoxGeometry(12, 5, 0.2);
            const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
            backWall.position.set(0, 2, -6);
            backWall.receiveShadow = true;
            walls.add(backWall);

            // ç™½æ¿
            const boardGeometry = new THREE.BoxGeometry(5, 2.5, 0.1);
            const boardMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xf5f5f5,
                emissive: 0xffffff,
                emissiveIntensity: 0.1
            });
            const board = new THREE.Mesh(boardGeometry, boardMaterial);
            board.position.set(0, 3, -5.89);
            board.receiveShadow = true;
            walls.add(board);

            // ç™½æ¿æ¨™é¡Œï¼ˆå¾ URL content å‚³å…¥ï¼‰
            const boardTitle = getBoardTitle();
            if (boardTitle) {
                const canvas = document.createElement('canvas');
                canvas.width = 1024;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');

                // èƒŒæ™¯é€æ˜
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // æ–‡å­—æ¨£å¼
                ctx.font = 'bold 80px Arial, system-ui, -apple-system, BlinkMacSystemFont';
                ctx.fillStyle = '#156697';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(boardTitle, canvas.width / 2, canvas.height / 2);

                const titleTexture = new THREE.CanvasTexture(canvas);
                titleTexture.needsUpdate = true;

                const titleWidth = 2.5;
                const titleHeight = titleWidth * (canvas.height / canvas.width);
                const titleGeo = new THREE.PlaneGeometry(titleWidth, titleHeight);
                const titleMat = new THREE.MeshBasicMaterial({
                    map: titleTexture,
                    transparent: true,
                    side: THREE.DoubleSide
                });
                const titleMesh = new THREE.Mesh(titleGeo, titleMat);
                // æ”¾åœ¨ header-icon ä¸Šæ–¹ä¸€äº›
                titleMesh.position.set(0, 0.9, 0.061);
                board.add(titleMesh);
            }

            // åœ¨ç™½æ¿ä¸­å¤®è²¼ä¸Š Alphacurve header icon åœ–ç‰‡
            // SVG å°ºå¯¸ç´„ 40x37ï¼Œé€™è£¡ç”¨ç›¸åŒé•·å¯¬æ¯”å»ºç«‹å¹³é¢
            const logoAspect = 37 / 40;
            const logoWidth = 0.8;
            const logoHeight = logoWidth * logoAspect;

            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(
                '/header-icon.svg',
                (texture) => {
                    // è¨­ç½®ç´‹ç†åƒæ•¸ä»¥ç¢ºä¿ SVG æ­£ç¢ºé¡¯ç¤º
                    texture.flipY = false;
                    texture.needsUpdate = true;
                    
                    const logoGeo = new THREE.PlaneGeometry(logoWidth, logoHeight);
                    const logoMat = new THREE.MeshBasicMaterial({
                        map: texture,
                        transparent: true,
                        side: THREE.DoubleSide
                    });
                    const logoMesh = new THREE.Mesh(logoGeo, logoMat);
                    // åœ¨ç™½æ¿çš„å±€éƒ¨åæ¨™ç³»ä¸­ï¼Œç¨å¾®å¾€å‰ç§»ï¼Œé¿å… Z-fighting
                    // ç™½æ¿é¢å‘ +Z æ–¹å‘ï¼Œæ‰€ä»¥ logo æ‡‰è©²åœ¨ +Z æ–¹å‘
                    logoMesh.position.set(0, 0, 0.06);
                    // ç›®å‰ç´‹ç†é¡¯ç¤ºä¸Šä¸‹é¡›å€’ï¼Œå°‡å¹³é¢ç¹ X è»¸æ—‹è½‰ 180 åº¦è½‰æ­£
                    logoMesh.rotation.x = Math.PI;
                    board.add(logoMesh);
                },
                undefined,
                (err) => {
                    console.warn('Failed to load header-icon.svg texture', err);
                }
            );

            return walls;
        }

        const walls = createWalls();
        scene.add(walls);

        // å°è©±æ°£æ³¡ï¼ˆHTML overlayï¼‰
        const bubble = document.createElement('div');
        bubble.className = 'room2-speech-bubble';
        bubble.style.position = 'fixed';
        bubble.style.zIndex = '10';
        bubble.style.padding = '6px 10px';
        bubble.style.borderRadius = '12px';
        bubble.style.background = 'rgba(0, 0, 0, 0.7)';
        bubble.style.color = '#fff';
        bubble.style.fontSize = '11px';
        bubble.style.fontFamily = 'Inter, system-ui, -apple-system, BlinkMacSystemFont, sans-serif';
        bubble.style.maxWidth = '180px';
        bubble.style.pointerEvents = 'none';
        bubble.style.boxShadow = '0 2px 8px rgba(0,0,0,0.35)';
        bubble.style.opacity = '0';
        bubble.style.transition = 'opacity 0.3s ease';
        document.body.appendChild(bubble);

        // è®€å–æ–‡æœ¬å…§å®¹
        const textContent = getTextContent();
        
        // èŠå¤©æç¤ºå°è©±æ¡†
        const chatPromptDialog = document.createElement('div');
        chatPromptDialog.style.position = 'fixed';
        chatPromptDialog.style.top = '50%';
        chatPromptDialog.style.left = '50%';
        chatPromptDialog.style.transform = 'translate(-50%, -50%)';
        chatPromptDialog.style.zIndex = '1000';
        chatPromptDialog.style.background = 'rgba(255, 255, 255, 0.95)';
        chatPromptDialog.style.padding = '20px 30px';
        chatPromptDialog.style.borderRadius = '16px';
        chatPromptDialog.style.boxShadow = '0 4px 20px rgba(0,0,0,0.3)';
        chatPromptDialog.style.fontFamily = 'Inter, system-ui, -apple-system, BlinkMacSystemFont, sans-serif';
        chatPromptDialog.style.fontSize = '18px';
        chatPromptDialog.style.color = '#333';
        chatPromptDialog.style.textAlign = 'center';
        chatPromptDialog.style.display = 'none';
        chatPromptDialog.textContent = textContent.chatPrompt;
        document.body.appendChild(chatPromptDialog);

        // è¼¸å…¥æ¡†å®¹å™¨
        const inputContainer = document.createElement('div');
        inputContainer.style.position = 'fixed';
        inputContainer.style.bottom = '30px';
        inputContainer.style.left = '50%';
        inputContainer.style.transform = 'translateX(-50%)';
        inputContainer.style.zIndex = '1000';
        inputContainer.style.background = 'rgba(255, 255, 255, 0.95)';
        inputContainer.style.padding = '15px 20px';
        inputContainer.style.borderRadius = '12px';
        inputContainer.style.boxShadow = '0 4px 20px rgba(0,0,0,0.3)';
        inputContainer.style.display = 'none';
        inputContainer.style.width = '90%';
        inputContainer.style.maxWidth = '500px';
        inputContainer.style.fontFamily = 'Inter, system-ui, -apple-system, BlinkMacSystemFont, sans-serif';

        const inputWrapper = document.createElement('div');
        inputWrapper.style.display = 'flex';
        inputWrapper.style.gap = '10px';
        inputWrapper.style.alignItems = 'center';

        const questionInput = document.createElement('input');
        questionInput.type = 'text';
        questionInput.placeholder = textContent.inputPlaceholder;
        questionInput.style.flex = '1';
        questionInput.style.padding = '10px 15px';
        questionInput.style.border = '2px solid #e0e0e0';
        questionInput.style.borderRadius = '8px';
        questionInput.style.fontSize = '14px';
        questionInput.style.fontFamily = 'Inter, system-ui, -apple-system, BlinkMacSystemFont, sans-serif';
        questionInput.style.outline = 'none';
        questionInput.style.transition = 'border-color 0.3s';
        questionInput.addEventListener('focus', () => {
            questionInput.style.borderColor = '#156697';
        });
        questionInput.addEventListener('blur', () => {
            questionInput.style.borderColor = '#e0e0e0';
        });

        const sendButton = document.createElement('button');
        sendButton.textContent = textContent.sendButton;
        sendButton.style.padding = '10px 20px';
        sendButton.style.background = '#156697';
        sendButton.style.color = '#fff';
        sendButton.style.border = 'none';
        sendButton.style.borderRadius = '8px';
        sendButton.style.fontSize = '14px';
        sendButton.style.fontFamily = 'Inter, system-ui, -apple-system, BlinkMacSystemFont, sans-serif';
        sendButton.style.cursor = 'pointer';
        sendButton.style.transition = 'background 0.3s';
        sendButton.addEventListener('mouseenter', () => {
            sendButton.style.background = '#0f4d6e';
        });
        sendButton.addEventListener('mouseleave', () => {
            sendButton.style.background = '#156697';
        });

        inputWrapper.appendChild(questionInput);
        inputWrapper.appendChild(sendButton);
        inputContainer.appendChild(inputWrapper);
        document.body.appendChild(inputContainer);

        // é¡¯ç¤ºæç¤ºå°è©±æ¡†ï¼Œç„¶å¾Œé¡¯ç¤ºè¼¸å…¥æ¡†
        let promptShown = false;
        function showChatPrompt() {
            if (promptShown) return;
            promptShown = true;
            
            // é¡¯ç¤ºæç¤ºå°è©±æ¡†
            chatPromptDialog.style.display = 'block';
            chatPromptDialog.style.opacity = '0';
            chatPromptDialog.style.transform = 'translate(-50%, -50%) scale(0.9)';
            
            setTimeout(() => {
                chatPromptDialog.style.transition = 'opacity 0.3s, transform 0.3s';
                chatPromptDialog.style.opacity = '1';
                chatPromptDialog.style.transform = 'translate(-50%, -50%) scale(1)';
            }, 10);

            // 3ç§’å¾Œéš±è—æç¤ºï¼Œé¡¯ç¤ºè¼¸å…¥æ¡†
            setTimeout(() => {
                chatPromptDialog.style.opacity = '0';
                chatPromptDialog.style.transform = 'translate(-50%, -50%) scale(0.9)';
                setTimeout(() => {
                    chatPromptDialog.style.display = 'none';
                    inputContainer.style.display = 'block';
                    inputContainer.style.opacity = '0';
                    setTimeout(() => {
                        inputContainer.style.transition = 'opacity 0.3s';
                        inputContainer.style.opacity = '1';
                        questionInput.focus();
                    }, 10);
                }, 300);
            }, 3000);
        }

        // å»¶é²é¡¯ç¤ºæç¤ºï¼ˆé€²å…¥æˆ¿é–“å¾Œ2ç§’ï¼‰
        setTimeout(showChatPrompt, 2000);

        // ç™¼é€å•é¡Œåˆ° API
        async function sendQuestion(question) {
            if (!question.trim()) return;

            // é¡¯ç¤ºè¼‰å…¥ç‹€æ…‹
            sendButton.disabled = true;
            sendButton.textContent = textContent.loadingText;
            sendButton.style.background = '#999';

            try {
                // ç¢ºå®š API URLï¼ˆèˆ‡ submit è¡¨å–®ä¿æŒä¸€è‡´ï¼‰
                // å¦‚æœæ˜¯ localhostï¼Œä½¿ç”¨æœ¬åœ° APIï¼›å¦å‰‡ä½¿ç”¨ç”Ÿç”¢ç’°å¢ƒçš„ API è·¯å¾‘
                let apiUrl;
                if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                    apiUrl = 'http://localhost:8080/api/chat';
                } else {
                    // ç”Ÿç”¢ç’°å¢ƒï¼šä½¿ç”¨èˆ‡ submit è¡¨å–®ç›¸åŒçš„ API è·¯å¾‘
                    // submit è¡¨å–®ä½¿ç”¨ï¼šhttps://alphacurve.io/website/api/submit
                    // chat API ä½¿ç”¨ï¼šhttps://alphacurve.io/api/chat
                    const protocol = window.location.protocol;
                    const hostname = window.location.hostname;
                    apiUrl = `${protocol}//${hostname}/api/chat`;
                }

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ question: question.trim() })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                
                // é¡¯ç¤ºå›ç­”ï¼ˆä½¿ç”¨ç¬¬ä¸€å€‹å°äººï¼‰
                if (people.length > 0) {
                    showAnswerBubble(people[0], data.answer);
                }

                // æ¸…ç©ºè¼¸å…¥æ¡†
                questionInput.value = '';
            } catch (error) {
                console.error('Error sending question:', error);
                // é¡¯ç¤ºéŒ¯èª¤è¨Šæ¯
                if (people.length > 0) {
                    showAnswerBubble(people[0], textContent.errorText);
                }
            } finally {
                sendButton.disabled = false;
                sendButton.textContent = textContent.sendButton;
                sendButton.style.background = '#156697';
            }
        }

        // é¡¯ç¤ºå›ç­”çš„å°è©±æ³¡æ³¡
        function showAnswerBubble(person, answer) {
            activeBubblePerson = person;
            bubble.textContent = answer;
            bubble.style.opacity = '1';
            bubbleVisibleUntil = performance.now() + 15000; // é¡¯ç¤º15ç§’ï¼ˆAIå›ç­”é€šå¸¸è¼ƒé•·ï¼‰

            // ç«‹å³æ›´æ–°æ³¡æ³¡ä½ç½®
            const worldPos = new THREE.Vector3();
            person.getWorldPosition(worldPos);
            worldPos.y += 2.4; // æŠŠæ°£æ³¡ç§»åˆ°é ­é ‚ä¸Šæ–¹ä¸€é»

            const projected = worldPos.clone().project(camera);
            const x = (projected.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-projected.y * 0.5 + 0.5) * window.innerHeight;

            bubble.style.left = `${x}px`;
            bubble.style.top = `${y - 20}px`;
            
            // é‡ç½®éš¨æ©Ÿå°è©±çš„æ™‚é–“ï¼Œé¿å…ç«‹å³åˆ‡æ›
            lastBubbleSwitch = performance.now();
        }

        // ç™¼é€æŒ‰éˆ•é»æ“Šäº‹ä»¶
        sendButton.addEventListener('click', () => {
            sendQuestion(questionInput.value);
        });

        // Enter éµç™¼é€
        questionInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendQuestion(questionInput.value);
            }
        });

        let activeBubblePerson = null;
        let bubbleVisibleUntil = 0;
        const bubbleDuration = 4000; // æ°£æ³¡é¡¯ç¤º 4 ç§’
        const bubbleInterval = 5500; // ç´„æ¯ 5.5 ç§’éš¨æ©Ÿå‡ºç¾ä¸€æ¬¡
        let lastBubbleSwitch = 0;

        // æ»‘é¼ æ§åˆ¶
        let mouseX = 0;
        let mouseY = 0;
        let targetRotationX = 0;
        let targetRotationY = 0;
        let isMouseDown = false;

        // ç›¸æ©Ÿç¸®æ”¾ï¼ˆè·é›¢ï¼‰æ§åˆ¶
        let cameraRadius = camera.position.length();   // ç›®å‰ç›¸æ©Ÿåˆ°åŸé»çš„è·é›¢
        const minRadius = 10;  // æœ€é è¿‘çš„è·é›¢
        const maxRadius = 22;  // æœ€é çš„è·é›¢

        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;

            // å¦‚æœæ»‘é¼ æŒ‰ä¸‹ï¼Œæ—‹è½‰ç›¸æ©Ÿ
            if (isMouseDown) {
                targetRotationY += event.movementX * 0.005;
                targetRotationX += event.movementY * 0.005;
                targetRotationX = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, targetRotationX));
            }
        });

        document.addEventListener('mousedown', () => {
            isMouseDown = true;
        });

        document.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        // æ»¾è¼ªç¸®æ”¾ï¼ˆé™åˆ¶åœ¨æŒ‡å®šè·é›¢ç¯„åœï¼‰
        document.addEventListener('wheel', (event) => {
            event.preventDefault();

            // deltaY > 0 æ»¾è¼ªå¾€ä¸‹ï¼ˆæ‹‰é ï¼‰ï¼ŒdeltaY < 0 æ»¾è¼ªå¾€ä¸Šï¼ˆæ‹‰è¿‘ï¼‰
            cameraRadius += event.deltaY * 0.02;
            cameraRadius = Math.max(minRadius, Math.min(maxRadius, cameraRadius));
        }, { passive: false });

        // è§¸æ§æ”¯æ´
        let touchStartX = 0;
        let touchStartY = 0;

        document.addEventListener('touchstart', (event) => {
            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;
        });

        document.addEventListener('touchmove', (event) => {
            const touch = event.touches[0];
            mouseX = (touch.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(touch.clientY / window.innerHeight) * 2 + 1;

            const deltaX = touch.clientX - touchStartX;
            const deltaY = touch.clientY - touchStartY;

            targetRotationY += deltaX * 0.005;
            targetRotationX += deltaY * 0.005;
            targetRotationX = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, targetRotationX));

            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
        });

        // éŸ¿æ‡‰å¼
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // æ›´æ–°æ‰‹è‡‚åŠ¨ç”»
        let lastAnimationTime = performance.now();
        function updateArmAnimations() {
            const now = performance.now();
            const deltaTime = now - lastAnimationTime;
            lastAnimationTime = now;
            const cycleDuration = 4000; // ä¸€ä¸ªå®Œæ•´å‘¨æœŸï¼ˆæ¯«ç§’ï¼‰

            people.forEach(person => {
                const anim = person.userData.armAnimation;
                if (!anim) return;

                const leftArm = person.userData.leftArm;
                const rightArm = person.userData.rightArm;
                if (!leftArm || !rightArm) return;

                // æ›´æ–°æ—¶é—´
                anim.time += deltaTime;
                
                // ä¸ºå·¦å³æ‰‹è®¾ç½®ä¸åŒçš„æ—¶é—´åç§»ï¼Œé¿å…åŒæ—¶åŠ¨ä½œ
                const leftPhaseOffset = 0; // å·¦æ‰‹åç§»
                const rightPhaseOffset = 0.5; // å³æ‰‹åç§» 50%ï¼Œè¿™æ ·å·¦å³æ‰‹ä¸ä¼šåŒæ—¶åŠ¨ä½œ
                
                const basePhase = (anim.time % cycleDuration) / cycleDuration;
                const leftPhase = (basePhase + leftPhaseOffset) % 1;
                const rightPhase = (basePhase + rightPhaseOffset) % 1;

                // æ›´æ–°æ‰‹è‡‚åŠ¨ç”»
                function updateArm(arm, armType, baseRotationZ, phase) {
                    if (armType === 'none') {
                        // æ— åŠ¨ä½œï¼Œä¿æŒé»˜è®¤ä½ç½®
                        arm.rotation.z = baseRotationZ;
                        arm.rotation.x = 0;
                        return;
                    }

                    // é‡æ–°è®¾è®¡åŠ¨ç”»é˜¶æ®µï¼š
                    // 0-0.1: ä¸¾èµ· (0 -> 1)
                    // 0.1-0.2: ä¿æŒä¸¾èµ· (1)
                    // 0.2-0.3: æ”¾ä¸‹ (1 -> 0)
                    // 0.3-1.0: ä¼‘æ¯/æ”¾ä¸‹ (0)
                    let animAmount = 0;
                    if (phase < 0.1) {
                        // ä¸¾èµ·é˜¶æ®µï¼š0 åˆ° 1
                        animAmount = phase / 0.1;
                    } else if (phase < 0.2) {
                        // ä¿æŒä¸¾èµ·ï¼š1
                        animAmount = 1;
                    } else if (phase < 0.3) {
                        // æ”¾ä¸‹é˜¶æ®µï¼š1 åˆ° 0
                        animAmount = 1 - (phase - 0.2) / 0.1;
                    } else {
                        // ä¼‘æ¯é˜¶æ®µï¼š0ï¼ˆæ‰‹æ”¾ä¸‹ï¼‰
                        animAmount = 0;
                    }

                    switch (armType) {
                        case 'raise': {
                            // ä¸¾èµ·åˆæ”¾ä¸‹
                            const raiseAmount = animAmount * 1.2; // 0 åˆ° 1.2 å¼§åº¦
                            // å·¦æ‰‹ï¼ˆbaseRotationZ > 0ï¼‰æ—¶å¢åŠ ï¼Œå³æ‰‹ï¼ˆbaseRotationZ < 0ï¼‰æ—¶å‡å°‘
                            arm.rotation.z = baseRotationZ + (baseRotationZ > 0 ? raiseAmount : -raiseAmount);
                            arm.rotation.x = 0;
                            break;
                        }
                        case 'spread': {
                            // å‘å¤–å¼ å¼€åˆåˆèµ·æ¥
                            const spreadAmount = animAmount * 0.8; // 0 åˆ° 0.8 å¼§åº¦
                            // å·¦æ‰‹ï¼ˆbaseRotationZ > 0ï¼‰æ—¶å¢åŠ ï¼Œå³æ‰‹ï¼ˆbaseRotationZ < 0ï¼‰æ—¶å‡å°‘
                            arm.rotation.z = baseRotationZ + (baseRotationZ > 0 ? spreadAmount : -spreadAmount);
                            arm.rotation.x = 0;
                            break;
                        }
                        case 'point': {
                            // å‘å‰æŒ‡åˆæ”¾ä¸‹
                            const pointAmount = animAmount * 0.6;
                            // å‘å‰æŒ‡éœ€è¦è°ƒæ•´ z æ—‹è½¬ï¼ˆå‘å‰ï¼‰å’Œ x æ—‹è½¬ï¼ˆå‘ä¸‹å€¾æ–œï¼‰
                            arm.rotation.z = baseRotationZ - pointAmount * 0.5;
                            arm.rotation.x = pointAmount * 0.8; // å‘å‰å€¾æ–œ
                            break;
                        }
                    }
                }

                // æ›´æ–°å·¦å³æ‰‹ï¼ˆå·¦æ‰‹åŸºç¡€æ—‹è½¬æ˜¯ 0.3ï¼Œå³æ‰‹æ˜¯ -0.3ï¼‰
                // ä½¿ç”¨ä¸åŒçš„ phase åç§»ï¼Œè®©å·¦å³æ‰‹ä¸ä¼šåŒæ—¶åŠ¨ä½œ
                updateArm(leftArm, anim.leftArm, 0.3, leftPhase);
                updateArm(rightArm, anim.rightArm, -0.3, rightPhase);
            });
        }

        // æ›´æ–°çœ¼ç›ä½ç½®
        function updateEyes() {
            // å‰µå»ºä¸€å€‹è™›æ“¬çš„æ»‘é¼ ä½ç½®é»
            const vector = new THREE.Vector3(mouseX, mouseY, 0.5);
            vector.unproject(camera);
            
            const dir = vector.sub(camera.position).normalize();
            const distance = -camera.position.y / dir.y;
            const pos = camera.position.clone().add(dir.multiplyScalar(distance));

            people.forEach(person => {
                const eyes = person.userData.eyes;
                if (eyes) {
                    eyes.forEach(eye => {
                        const pupil = eye.userData.pupil;
                        if (pupil) {
                            // è¨ˆç®—çœ¼ç›çœ‹å‘æ»‘é¼ çš„æ–¹å‘
                            const eyeWorldPos = new THREE.Vector3();
                            eye.getWorldPosition(eyeWorldPos);

                            const lookDir = new THREE.Vector3()
                                .subVectors(pos, eyeWorldPos)
                                .normalize();

                            // å°‡æ–¹å‘è½‰æ›ç‚ºçœ¼ç›çš„å±€éƒ¨åæ¨™
                            const localDir = eye.worldToLocal(lookDir.clone().add(eyeWorldPos))
                                .sub(eye.worldToLocal(eyeWorldPos.clone()));

                            // é™åˆ¶ç³å­”ç§»å‹•ç¯„åœ
                            const maxDistance = 0.06;
                            const distance = Math.min(maxDistance, localDir.length());
                            localDir.normalize().multiplyScalar(distance);

                            pupil.position.x = localDir.x;
                            pupil.position.y = localDir.y;
                        }
                    });
                }
            });
        }

        // å°è©±æ°£æ³¡æ›´æ–°ï¼ˆéš¨æ©Ÿé¸ä¸€å€‹äººã€éš¨æ©Ÿä¸€å¥è©±ï¼‰
        function updateSpeechBubble() {
            const now = performance.now();

            // å¦‚æœç›®å‰æ²’æœ‰æ°£æ³¡æˆ–æ™‚é–“åˆ°äº†ï¼Œå˜—è©¦åˆ‡æ›åˆ°ä¸‹ä¸€å€‹
            if (!activeBubblePerson || now > bubbleVisibleUntil) {
                if (now - lastBubbleSwitch < bubbleInterval) {
                    // é‚„æ²’åˆ°ä¸‹ä¸€æ¬¡é¡¯ç¤ºæ™‚é–“ï¼Œéš±è—æ°£æ³¡
                    bubble.style.opacity = '0';
                    activeBubblePerson = null;
                    return;
                }

                const candidates = people.filter(p => Array.isArray(p.userData.messages) && p.userData.messages.length > 0);
                if (candidates.length === 0) {
                    bubble.style.opacity = '0';
                    activeBubblePerson = null;
                    return;
                }

                const person = candidates[Math.floor(Math.random() * candidates.length)];
                const msgs = person.userData.messages;
                const msg = msgs[Math.floor(Math.random() * msgs.length)];

                activeBubblePerson = person;
                bubble.textContent = msg;
                bubbleVisibleUntil = now + bubbleDuration;
                lastBubbleSwitch = now;
                bubble.style.opacity = '1';
            }

            // å¦‚æœæœ‰æ­£åœ¨é¡¯ç¤ºçš„æ°£æ³¡ï¼Œæ›´æ–°å…¶è¢å¹•åº§æ¨™
            if (activeBubblePerson) {
                const worldPos = new THREE.Vector3();
                activeBubblePerson.getWorldPosition(worldPos);
                worldPos.y += 2.4; // æŠŠæ°£æ³¡ç§»åˆ°é ­é ‚ä¸Šæ–¹ä¸€é»

                const projected = worldPos.clone().project(camera);
                const x = (projected.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-projected.y * 0.5 + 0.5) * window.innerHeight;

                bubble.style.left = `${x}px`;
                bubble.style.top = `${y - 20}px`;
            }
        }

        // å‹•ç•«å¾ªç’°
        function animate() {
            requestAnimationFrame(animate);

            // å¹³æ»‘æ—‹è½‰ç›¸æ©Ÿï¼ˆä½¿ç”¨å—é™åˆ¶çš„ cameraRadiusï¼‰
            const radius = cameraRadius;
            camera.position.x = radius * Math.sin(targetRotationY) * Math.cos(targetRotationX);
            camera.position.y = radius * Math.sin(targetRotationX) + 8;
            camera.position.z = radius * Math.cos(targetRotationY) * Math.cos(targetRotationX);
            camera.lookAt(0, 1, 0);

            // æ›´æ–°æ‰‹è‡‚åŠ¨ç”»
            updateArmAnimations();

            // æ›´æ–°çœ¼ç›
            updateEyes();

            // æ›´æ–°å°è©±æ°£æ³¡
            updateSpeechBubble();

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>


