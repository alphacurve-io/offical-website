<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alphacurve.io Meeting Room</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: #f0f0f0;
        }

        canvas {
            display: block;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #333;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        #info h3 {
            margin: 0 0 10px 0;
            color: #1a73e8;
        }
    </style>
</head>
<body>
    <!-- <div id="info">
        <h3>ğŸ§± Alphacurve.io Meeting Room</h3>
        <p>Drag mouse to rotate view</p>
        <p>Scroll wheel to zoom</p>
    </div> -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ç«‹å³å®šç¾©å…¨å±€å‡½æ•¸ï¼Œç¢ºä¿åœ¨ä»»ä½•æ™‚å€™éƒ½å¯ä»¥ä½¿ç”¨
        window.getCameraAngles = function() {
            // é€™å€‹å‡½æ•¸æœƒåœ¨å¾Œé¢çš„ä»£ç¢¼ä¸­é‡æ–°å®šç¾©ï¼Œé€™è£¡å…ˆå®šç¾©ä¸€å€‹å ä½ç¬¦
            console.log('âš ï¸ ç›¸æ©Ÿå°šæœªåˆå§‹åŒ–ï¼Œè«‹ç­‰å¾…é é¢å®Œå…¨åŠ è¼‰å¾Œå†ä½¿ç”¨æ­¤å‡½æ•¸');
            return null;
        };
        
        window.setAnswerCameraAngles = function(angles) {
            if (!angles || typeof angles !== 'object') {
                console.error('è«‹æä¾›è§’åº¦å°è±¡ï¼Œæ ¼å¼ï¼š{ radius, rotationX, rotationY, lookAtY }');
                return;
            }
            window.answerCameraAngles = {
                radius: angles.radius || 10,
                rotationX: angles.rotationX || 0,
                rotationY: angles.rotationY || 0,
                lookAtY: angles.lookAtY || 1.5
            };
            console.log('âœ… å›ç­”è§’åº¦å·²è¨­ç½®:', window.answerCameraAngles);
        };
        
        // å¾ URL åƒæ•¸è®€å–è‡ªè¨‚äººç‰©è¨­å®šï¼ˆç”± React å‚³å…¥ï¼‰
        // people = encodeURIComponent(JSON.stringify([{ bodyColor, hairColor, expression }, ...]))
        function getCustomPeopleConfigs() {
            try {
                const params = new URLSearchParams(window.location.search);
                const raw = params.get('people');
                if (!raw) return null;
                const decoded = decodeURIComponent(raw);
                const parsed = JSON.parse(decoded);
                if (!Array.isArray(parsed)) return null;
                return parsed;
            } catch (e) {
                console.warn('Failed to parse custom people config:', e);
                return null;
            }
        }

        // å¾ URL è®€å–ç™½æ¿æ¨™é¡Œï¼ˆç”± React å‚³å…¥ï¼‰
        function getBoardTitle() {
            try {
                const params = new URLSearchParams(window.location.search);
                const raw = params.get('title');
                if (!raw) return null;
                return decodeURIComponent(raw);
            } catch (e) {
                console.warn('Failed to parse board title:', e);
                return null;
            }
        }

        // å¾ URL è®€å–æ–‡æœ¬å…§å®¹ï¼ˆç”± React å‚³å…¥ï¼‰
        function getTextContent() {
            try {
                const params = new URLSearchParams(window.location.search);
                const raw = params.get('textContent');
                if (!raw) return null;
                const decoded = decodeURIComponent(raw);
                return JSON.parse(decoded);
            } catch (e) {
                console.warn('Failed to parse text content:', e);
                // è¿”å›é»˜èªæ–‡æœ¬
                return {
                    chatPrompt: 'ä½ æœ‰ä»€éº¼å•é¡Œæƒ³å•å—ï¼Ÿ',
                    inputPlaceholder: 'è¼¸å…¥ä½ çš„å•é¡Œ...',
                    sendButton: 'ç™¼é€',
                    loadingText: 'æ€è€ƒä¸­...',
                    errorText: 'æŠ±æ­‰ï¼Œç™¼ç”ŸéŒ¯èª¤ï¼Œè«‹ç¨å¾Œå†è©¦ã€‚'
                };
            }
        }

        function hexToColorNumber(hex, fallback) {
            if (!hex || typeof hex !== 'string') return fallback;
            const cleaned = hex.replace('#', '');
            const num = parseInt(cleaned, 16);
            return Number.isNaN(num) ? fallback : num;
        }

        // å ´æ™¯è¨­ç½®
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);

        // ç›¸æ©Ÿ
        const camera = new THREE.PerspectiveCamera(
            45,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 8, 15);
        camera.lookAt(0, 0, 0);

        // æ¸²æŸ“å™¨
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // å…‰æº
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -10;
        directionalLight.shadow.camera.right = 10;
        directionalLight.shadow.camera.top = 10;
        directionalLight.shadow.camera.bottom = -10;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // åœ°æ¿
        const floorGeometry = new THREE.PlaneGeometry(30, 30);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xe0e0e0,
            roughness: 0.8,
            metalness: 0.2
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -0.5;
        floor.receiveShadow = true;
        scene.add(floor);

        // å‰µå»ºæœ¨ç´‹ç´‹ç†
        function createWoodTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // åŸºç¤æœ¨è‰²
            ctx.fillStyle = '#8B6F47';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // æœ¨ç´‹æ¢ç´‹æ•ˆæœ
            for (let i = 0; i < canvas.width; i += 2) {
                const noise = Math.sin(i * 0.05) * 3;
                const brightness = 50 + Math.sin(i * 0.1) * 20;
                ctx.fillStyle = `rgba(${139 + brightness}, ${111 + brightness * 0.7}, ${71 + brightness * 0.5}, 0.3)`;
                ctx.fillRect(i, 0, 2, canvas.height);
            }

            // æ·»åŠ æœ¨ç´‹ç´°ç¯€
            for (let i = 0; i < 50; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const w = 1 + Math.random() * 2;
                const h = canvas.height;
                const alpha = 0.1 + Math.random() * 0.2;
                ctx.fillStyle = `rgba(${100 + Math.random() * 50}, ${80 + Math.random() * 40}, ${50 + Math.random() * 30}, ${alpha})`;
                ctx.fillRect(x, y, w, h);
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(2, 1); // æ©«å‘é‡è¤‡ï¼Œè®“æœ¨ç´‹æ›´è‡ªç„¶
            return texture;
        }

        // å‰µå»ºæœƒè­°æ¡Œ
        function createTable() {
            const table = new THREE.Group();

            // æ¡Œé¢ - ä½¿ç”¨æœ¨ç´‹æè³ª
            const topGeometry = new THREE.BoxGeometry(6, 0.2, 4);
            const woodTexture = createWoodTexture();
            const topMaterial = new THREE.MeshStandardMaterial({ 
                map: woodTexture,
                roughness: 0.7,
                metalness: 0.1
            });
            const top = new THREE.Mesh(topGeometry, topMaterial);
            top.position.y = 1;
            top.castShadow = true;
            top.receiveShadow = true;
            table.add(top);

            // æ¡Œè…³
            const legGeometry = new THREE.BoxGeometry(0.15, 1, 0.15);
            const legMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xcccccc,
                roughness: 0.5
            });

            const legPositions = [
                [-2.5, 0.5, -1.5],
                [2.5, 0.5, -1.5],
                [-2.5, 0.5, 1.5],
                [2.5, 0.5, 1.5]
            ];

            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                leg.position.set(...pos);
                leg.castShadow = true;
                table.add(leg);
            });

            // æ¡Œä¸Šç‰©å“ - ç­†è¨˜å‹é›»è…¦
            const laptopBase = new THREE.BoxGeometry(0.6, 0.05, 0.4);
            const laptopScreen = new THREE.BoxGeometry(0.6, 0.5, 0.05);
            const laptopMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            
            const laptop = new THREE.Group();
            const base = new THREE.Mesh(laptopBase, laptopMaterial);
            base.position.y = 1.15;
            const screen = new THREE.Mesh(laptopScreen, laptopMaterial);
            screen.position.set(0, 1.4, -0.15);
            screen.rotation.x = -0.3;
            laptop.add(base, screen);
            laptop.position.set(-1.5, 0, 0);
            table.add(laptop);

            // æ–‡ä»¶
            const docGeometry = new THREE.BoxGeometry(0.3, 0.02, 0.4);
            const docMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const document = new THREE.Mesh(docGeometry, docMaterial);
            document.position.set(1.5, 1.12, 0.5);
            table.add(document);

            // æ‰‹æ©Ÿ
            const phoneGeometry = new THREE.BoxGeometry(0.15, 0.02, 0.25);
            const phoneMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const phone = new THREE.Mesh(phoneGeometry, phoneMaterial);
            phone.position.set(0.8, 1.12, -0.8);
            table.add(phone);

            return table;
        }

        // å‰µå»ºæ¨‚é«˜äººç‰©
        // expression: 'neutral' | 'smile' | 'sad' | 'surprised'
        function createLegoPerson(bodyColor, hairColor, expression = 'neutral') {
            const person = new THREE.Group();

            // èº«é«”
            const bodyGeometry = new THREE.BoxGeometry(0.8, 1.2, 0.6);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: bodyColor,
                roughness: 0.4
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.6;
            body.castShadow = true;
            person.add(body);

            // é ­éƒ¨
            const headGeometry = new THREE.BoxGeometry(0.7, 0.8, 0.7);
            const headMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffd700,
                roughness: 0.3
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.5;
            head.castShadow = true;
            person.add(head);

            // é ­é«®
            const hairGeometry = new THREE.BoxGeometry(0.72, 0.3, 0.72);
            const hairMaterial = new THREE.MeshStandardMaterial({ 
                color: hairColor,
                roughness: 0.6
            });
            const hair = new THREE.Mesh(hairGeometry, hairMaterial);
            hair.position.y = 2.05;
            hair.castShadow = true;
            person.add(hair);

            // çœ¼ç›å®¹å™¨
            const eyesGroup = new THREE.Group();
            eyesGroup.position.set(0, 1.6, 0.36);

            // å·¦çœ¼
            const leftEye = createEye();
            leftEye.position.x = -0.2;
            eyesGroup.add(leftEye);

            // å³çœ¼
            const rightEye = createEye();
            rightEye.position.x = 0.2;
            eyesGroup.add(rightEye);

            person.add(eyesGroup);
            person.userData.eyes = [leftEye, rightEye];

            // å˜´å·´ï¼ˆè¡¨æƒ…ï¼‰
            let mouth;
            if (expression === 'surprised') {
                // é©šè¨ï¼šåœ“å½¢å˜´å·´
                const mouthGeometry = new THREE.CircleGeometry(0.11, 28);
                const mouthMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x000000,
                    side: THREE.DoubleSide
                });
                mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
                mouth.position.set(0, 1.34, 0.37);
            } else if (expression === 'smile') {
                // ç¬‘è‡‰ï¼šä½¿ç”¨å¼§å½¢ Shape å¹¾ä½•åšå‡ºçœŸæ­£çš„å¾®ç¬‘æ›²ç·š
                const width = 0.6;
                const height = 0.16;
                const thickness = 0.05;

                const smileShape = new THREE.Shape();
                // å¤–å¼§ç·šï¼ˆå¾€ä¸‹å½ï¼‰
                smileShape.moveTo(-width / 2, 0);
                smileShape.quadraticCurveTo(0, -height, width / 2, 0);
                // å…§å¼§ç·šï¼ˆå¾€ä¸‹å½ï¼Œç¨å¾®é ä¸Šå½¢æˆå¼§å½¢æ¢å¸¶ï¼‰
                const innerOffset = 0.04;
                smileShape.lineTo(width / 2, innerOffset);
                smileShape.quadraticCurveTo(0, -height + innerOffset, -width / 2, innerOffset);
                smileShape.closePath();

                const mouthGeometry = new THREE.ShapeGeometry(smileShape, 24);
                const mouthMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff4444,
                    emissive: 0x330000,
                    emissiveIntensity: 0.4
                });
                mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
                mouth.position.set(0, 1.36, 0.36 + thickness / 2);
            } else if (expression === 'sad') {
                // é›£éï¼šæ¯”è¼ƒçŸ­ã€ç•¥é«˜ã€é¡è‰²åæ·±
                const mouthGeometry = new THREE.BoxGeometry(0.28, 0.05, 0.05);
                const mouthMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x111111
                });
                mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
                mouth.position.set(0, 1.49, 0.36);
            } else {
                // ä¸­æ€§è¡¨æƒ…
                const mouthGeometry = new THREE.BoxGeometry(0.35, 0.05, 0.05);
                const mouthMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x000000
                });
                mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
                mouth.position.set(0, 1.41, 0.36);
            }
            person.add(mouth);

            // æ‰‹è‡‚
            const armGeometry = new THREE.BoxGeometry(0.2, 0.8, 0.2);
            const armMaterial = new THREE.MeshStandardMaterial({ 
                color: bodyColor,
                roughness: 0.4
            });

            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.5, 0.8, 0);
            leftArm.rotation.z = 0.3;
            leftArm.castShadow = true;
            person.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.5, 0.8, 0);
            rightArm.rotation.z = -0.3;
            rightArm.castShadow = true;
            person.add(rightArm);

            // å­˜å‚¨æ‰‹è‡‚å¼•ç”¨ä»¥ä¾¿åŠ¨ç”»
            person.userData.leftArm = leftArm;
            person.userData.rightArm = rightArm;
            person.userData.armAnimation = {
                leftArm: 'none', // 'none', 'raise', 'point', 'spread'
                rightArm: 'none', // 'none', 'raise', 'point', 'spread'
                time: 0
            };

            return person;
        }

        // å‰µå»ºçœ¼ç›
        function createEye() {
            const eyeGroup = new THREE.Group();

            // çœ¼ç™½
            const whiteGeometry = new THREE.CircleGeometry(0.12, 16);
            const whiteMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffffff,
                side: THREE.DoubleSide
            });
            const white = new THREE.Mesh(whiteGeometry, whiteMaterial);
            eyeGroup.add(white);

            // çœ¼ç ï¼ˆå¯ç§»å‹•ï¼‰
            const pupilGeometry = new THREE.CircleGeometry(0.05, 16);
            const pupilMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x000000,
                side: THREE.DoubleSide
            });
            const pupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            pupil.position.z = 0.01;
            eyeGroup.add(pupil);

            eyeGroup.userData.pupil = pupil;

            return eyeGroup;
        }

        // æ·»åŠ æœƒè­°æ¡Œ
        const table = createTable();
        scene.add(table);

        // æ·»åŠ äººç‰©
        const people = [];

        const defaultPersonConfigs = [
            // æ­£é¢ä¸‰äºº
            { pos: [-3, 0, -3], rot: 0.5, body: 0x2c5f2d, hair: 0x654321, expression: 'smile', leftArm: 'raise', rightArm: 'raise' },
            { pos: [0, 0, -3], rot: 0, body: 0x1e3a5f, hair: 0xffd700, expression: 'surprised', leftArm: 'spread', rightArm: 'spread' },
            { pos: [3, 0, -3], rot: -0.5, body: 0x1a1a4e, hair: 0x8b4513, expression: 'neutral', leftArm: 'none', rightArm: 'point' },
            // èƒŒé¢ä¸‰äºº
            { pos: [-3, 0, 3], rot: 2.6, body: 0x1a1a4e, hair: 0x8b4513, expression: 'sad', leftArm: 'raise', rightArm: 'none' },
            { pos: [0, 0, 3], rot: Math.PI, body: 0x2c5f2d, hair: 0xffa500, expression: 'smile', leftArm: 'spread', rightArm: 'raise' },
            { pos: [3, 0, 3], rot: -2.6, body: 0x1e3a5f, hair: 0x654321, expression: 'neutral', leftArm: 'point', rightArm: 'spread' }
        ];

        const externalPeople = getCustomPeopleConfigs();

        const personConfigs = defaultPersonConfigs.map((cfg, index) => {
            const override = externalPeople && externalPeople[index] ? externalPeople[index] : {};
            return {
                ...cfg,
                body: hexToColorNumber(override.bodyColor, cfg.body),
                hair: hexToColorNumber(override.hairColor, cfg.hair),
                expression: override.expression || cfg.expression,
                messages: Array.isArray(override.messages) ? override.messages : (cfg.messages || []),
                leftArm: override.leftArm || cfg.leftArm || 'none',
                rightArm: override.rightArm || cfg.rightArm || 'none',
            };
        });

        personConfigs.forEach((config, index) => {
            const person = createLegoPerson(config.body, config.hair, config.expression);
            person.position.set(...config.pos);
            person.rotation.y = config.rot;
            person.userData.messages = config.messages || [];
            // è®¾ç½®å·¦å³æ‰‹åŠ¨ç”»ç±»å‹ï¼Œæ¯ä¸ªäººç‰©æœ‰ä¸åŒçš„åŠ¨ç”»å»¶è¿Ÿ
            person.userData.armAnimation.leftArm = config.leftArm || 'none';
            person.userData.armAnimation.rightArm = config.rightArm || 'none';
            // ä¸ºæ¯ä¸ªäººç‰©è®¾ç½®ä¸åŒçš„æ—¶é—´åç§»ï¼Œé¿å…æ‰€æœ‰äººåŒæ—¶åŠ¨ä½œ
            // æ¯ä¸ªäººç‰©åç§» 1/6 çš„å‘¨æœŸï¼ˆçº¦ 667msï¼‰ï¼Œè¿™æ ·6ä¸ªäººç‰©çš„åŠ¨ä½œä¼šå®Œå…¨é”™å¼€
            const cycleDuration = 4000;
            person.userData.armAnimation.time = (index / personConfigs.length) * cycleDuration;
            scene.add(person);
            people.push(person);
        });

        // ç‰†å£èˆ‡ç™½æ¿
        function createWalls() {
            const walls = new THREE.Group();

            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffffff,
                roughness: 0.6
            });

            // åƒ…ä¿ç•™å¾Œæ–¹é€™é¢ç‰†ï¼ˆå…¶ä»–å´ç‰†ç§»é™¤ï¼‰
            const backWallGeometry = new THREE.BoxGeometry(12, 5, 0.2);
            const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
            backWall.position.set(0, 2, -6);
            backWall.receiveShadow = true;
            walls.add(backWall);

            // ç™½æ¿
            const boardGeometry = new THREE.BoxGeometry(5, 2.5, 0.1);
            const boardMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xf5f5f5,
                emissive: 0xffffff,
                emissiveIntensity: 0.1
            });
            const board = new THREE.Mesh(boardGeometry, boardMaterial);
            board.position.set(0, 3, -5.89);
            board.receiveShadow = true;
            walls.add(board);

            // ç™½æ¿æ¨™é¡Œï¼ˆå¾ URL content å‚³å…¥ï¼‰
            const boardTitle = getBoardTitle();
            if (boardTitle) {
                const canvas = document.createElement('canvas');
                canvas.width = 1024;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');

                // èƒŒæ™¯é€æ˜
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // æ–‡å­—æ¨£å¼
                ctx.font = 'bold 80px Arial, system-ui, -apple-system, BlinkMacSystemFont';
                ctx.fillStyle = '#156697';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(boardTitle, canvas.width / 2, canvas.height / 2);

                const titleTexture = new THREE.CanvasTexture(canvas);
                titleTexture.needsUpdate = true;

                const titleWidth = 2.5;
                const titleHeight = titleWidth * (canvas.height / canvas.width);
                const titleGeo = new THREE.PlaneGeometry(titleWidth, titleHeight);
                const titleMat = new THREE.MeshBasicMaterial({
                    map: titleTexture,
                    transparent: true,
                    side: THREE.DoubleSide
                });
                const titleMesh = new THREE.Mesh(titleGeo, titleMat);
                // æ”¾åœ¨ header-icon ä¸Šæ–¹ä¸€äº›
                titleMesh.position.set(0, 0.9, 0.061);
                board.add(titleMesh);
            }

            // åœ¨ç™½æ¿ä¸­å¤®è²¼ä¸Š Alphacurve header icon åœ–ç‰‡
            // SVG å°ºå¯¸ç´„ 40x37ï¼Œé€™è£¡ç”¨ç›¸åŒé•·å¯¬æ¯”å»ºç«‹å¹³é¢
            const logoAspect = 37 / 40;
            const logoWidth = 0.8;
            const logoHeight = logoWidth * logoAspect;

            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(
                '/header-icon.svg',
                (texture) => {
                    // è¨­ç½®ç´‹ç†åƒæ•¸ä»¥ç¢ºä¿ SVG æ­£ç¢ºé¡¯ç¤º
                    texture.flipY = false;
                    texture.needsUpdate = true;
                    
                    const logoGeo = new THREE.PlaneGeometry(logoWidth, logoHeight);
                    const logoMat = new THREE.MeshBasicMaterial({
                        map: texture,
                        transparent: true,
                        side: THREE.DoubleSide
                    });
                    const logoMesh = new THREE.Mesh(logoGeo, logoMat);
                    // åœ¨ç™½æ¿çš„å±€éƒ¨åæ¨™ç³»ä¸­ï¼Œç¨å¾®å¾€å‰ç§»ï¼Œé¿å… Z-fighting
                    // ç™½æ¿é¢å‘ +Z æ–¹å‘ï¼Œæ‰€ä»¥ logo æ‡‰è©²åœ¨ +Z æ–¹å‘
                    logoMesh.position.set(0, 0, 0.06);
                    // ç›®å‰ç´‹ç†é¡¯ç¤ºä¸Šä¸‹é¡›å€’ï¼Œå°‡å¹³é¢ç¹ X è»¸æ—‹è½‰ 180 åº¦è½‰æ­£
                    logoMesh.rotation.x = Math.PI;
                    board.add(logoMesh);
                },
                undefined,
                (err) => {
                    console.warn('Failed to load header-icon.svg texture', err);
                }
            );

            return walls;
        }

        const walls = createWalls();
        scene.add(walls);

        // å°è©±æ°£æ³¡ï¼ˆHTML overlayï¼‰
        const bubble = document.createElement('div');
        bubble.className = 'room2-speech-bubble';
        bubble.style.position = 'fixed';
        bubble.style.zIndex = '10';
        bubble.style.padding = '6px 10px';
        bubble.style.borderRadius = '12px';
        bubble.style.background = 'rgba(0, 0, 0, 0.7)';
        bubble.style.color = '#fff';
        bubble.style.fontSize = '11px';
        bubble.style.fontFamily = 'Inter, system-ui, -apple-system, BlinkMacSystemFont, sans-serif';
        bubble.style.maxWidth = '180px';
        bubble.style.pointerEvents = 'none';
        bubble.style.boxShadow = '0 2px 8px rgba(0,0,0,0.35)';
        bubble.style.opacity = '0';
        bubble.style.transition = 'opacity 0.3s ease';
        document.body.appendChild(bubble);

        // è®€å–æ–‡æœ¬å…§å®¹
        const textContent = getTextContent();
        
        // èŠå¤©æç¤ºå°è©±æ¡†
        const chatPromptDialog = document.createElement('div');
        chatPromptDialog.style.position = 'fixed';
        chatPromptDialog.style.top = '50%';
        chatPromptDialog.style.left = '50%';
        chatPromptDialog.style.transform = 'translate(-50%, -50%)';
        chatPromptDialog.style.zIndex = '1000';
        chatPromptDialog.style.background = 'rgba(255, 255, 255, 0.95)';
        chatPromptDialog.style.padding = '20px 30px';
        chatPromptDialog.style.borderRadius = '16px';
        chatPromptDialog.style.boxShadow = '0 4px 20px rgba(0,0,0,0.3)';
        chatPromptDialog.style.fontFamily = 'Inter, system-ui, -apple-system, BlinkMacSystemFont, sans-serif';
        chatPromptDialog.style.fontSize = '18px';
        chatPromptDialog.style.color = '#333';
        chatPromptDialog.style.textAlign = 'center';
        chatPromptDialog.style.display = 'none';
        chatPromptDialog.textContent = textContent.chatPrompt;
        document.body.appendChild(chatPromptDialog);

        // è¼¸å…¥æ¡†å®¹å™¨
        const inputContainer = document.createElement('div');
        inputContainer.style.position = 'fixed';
        inputContainer.style.bottom = '30px';
        inputContainer.style.left = '50%';
        inputContainer.style.transform = 'translateX(-50%)';
        inputContainer.style.zIndex = '1000';
        inputContainer.style.background = 'rgba(255, 255, 255, 0.95)';
        inputContainer.style.padding = '15px 20px';
        inputContainer.style.borderRadius = '12px';
        inputContainer.style.boxShadow = '0 4px 20px rgba(0,0,0,0.3)';
        inputContainer.style.display = 'none';
        inputContainer.style.width = '90%';
        inputContainer.style.maxWidth = '500px';
        inputContainer.style.fontFamily = 'Inter, system-ui, -apple-system, BlinkMacSystemFont, sans-serif';

        const inputWrapper = document.createElement('div');
        inputWrapper.style.display = 'flex';
        inputWrapper.style.gap = '10px';
        inputWrapper.style.alignItems = 'center';

        const questionInput = document.createElement('input');
        questionInput.type = 'text';
        questionInput.placeholder = textContent.inputPlaceholder;
        questionInput.style.flex = '1';
        questionInput.style.padding = '10px 15px';
        questionInput.style.border = '2px solid #e0e0e0';
        questionInput.style.borderRadius = '8px';
        questionInput.style.fontSize = '14px';
        questionInput.style.fontFamily = 'Inter, system-ui, -apple-system, BlinkMacSystemFont, sans-serif';
        questionInput.style.outline = 'none';
        questionInput.style.transition = 'border-color 0.3s';
        questionInput.addEventListener('focus', () => {
            questionInput.style.borderColor = '#156697';
        });
        questionInput.addEventListener('blur', () => {
            questionInput.style.borderColor = '#e0e0e0';
        });

        const sendButton = document.createElement('button');
        sendButton.textContent = textContent.sendButton;
        sendButton.style.padding = '10px 20px';
        sendButton.style.background = '#156697';
        sendButton.style.color = '#fff';
        sendButton.style.border = 'none';
        sendButton.style.borderRadius = '8px';
        sendButton.style.fontSize = '14px';
        sendButton.style.fontFamily = 'Inter, system-ui, -apple-system, BlinkMacSystemFont, sans-serif';
        sendButton.style.cursor = 'pointer';
        sendButton.style.transition = 'background 0.3s';
        sendButton.addEventListener('mouseenter', () => {
            sendButton.style.background = '#0f4d6e';
        });
        sendButton.addEventListener('mouseleave', () => {
            sendButton.style.background = '#156697';
        });

        inputWrapper.appendChild(questionInput);
        inputWrapper.appendChild(sendButton);
        inputContainer.appendChild(inputWrapper);
        document.body.appendChild(inputContainer);

        // é¡¯ç¤ºæç¤ºå°è©±æ¡†ï¼Œç„¶å¾Œé¡¯ç¤ºè¼¸å…¥æ¡†
        let promptShown = false;
        function showChatPrompt() {
            if (promptShown) return;
            promptShown = true;
            
            // é¡¯ç¤ºæç¤ºå°è©±æ¡†
            chatPromptDialog.style.display = 'block';
            chatPromptDialog.style.opacity = '0';
            chatPromptDialog.style.transform = 'translate(-50%, -50%) scale(0.9)';
            
            setTimeout(() => {
                chatPromptDialog.style.transition = 'opacity 0.3s, transform 0.3s';
                chatPromptDialog.style.opacity = '1';
                chatPromptDialog.style.transform = 'translate(-50%, -50%) scale(1)';
            }, 10);

            // 3ç§’å¾Œéš±è—æç¤ºï¼Œé¡¯ç¤ºè¼¸å…¥æ¡†
            setTimeout(() => {
                chatPromptDialog.style.opacity = '0';
                chatPromptDialog.style.transform = 'translate(-50%, -50%) scale(0.9)';
                setTimeout(() => {
                    chatPromptDialog.style.display = 'none';
                    inputContainer.style.display = 'block';
                    inputContainer.style.opacity = '0';
                    setTimeout(() => {
                        inputContainer.style.transition = 'opacity 0.3s';
                        inputContainer.style.opacity = '1';
                        questionInput.focus();
                    }, 10);
                }, 300);
            }, 3000);
        }

        // å»¶é²é¡¯ç¤ºæç¤ºï¼ˆé€²å…¥æˆ¿é–“å¾Œ2ç§’ï¼‰
        setTimeout(showChatPrompt, 2000);

        // ç™¼é€å•é¡Œåˆ° API
        async function sendQuestion(question) {
            if (!question.trim()) return;

            // é¡¯ç¤ºè¼‰å…¥ç‹€æ…‹
            sendButton.disabled = true;
            sendButton.textContent = textContent.loadingText;
            sendButton.style.background = '#999';

            try {
                // ç¢ºå®š API URLï¼ˆèˆ‡ submit è¡¨å–®ä¿æŒä¸€è‡´ï¼‰
                // å¦‚æœæ˜¯ localhostï¼Œä½¿ç”¨æœ¬åœ° APIï¼›å¦å‰‡ä½¿ç”¨ç”Ÿç”¢ç’°å¢ƒçš„ API è·¯å¾‘
                let apiUrl;
                if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                    apiUrl = 'http://localhost:8080/api/chat';
                } else {
                    // ç”Ÿç”¢ç’°å¢ƒï¼šä½¿ç”¨èˆ‡ submit è¡¨å–®ç›¸åŒçš„ API è·¯å¾‘
                    // submit è¡¨å–®ä½¿ç”¨ï¼šhttps://alphacurve.io/website/api/submit
                    // chat API ä½¿ç”¨ï¼šhttps://alphacurve.io/api/chat
                    const protocol = window.location.protocol;
                    const hostname = window.location.hostname;
                    apiUrl = `${protocol}//${hostname}/api/chat`;
                }

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ question: question.trim() })
                });

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const data = await response.json();
                
                // é¡¯ç¤ºå›ç­”ï¼ˆä½¿ç”¨ç¬¬ä¸€å€‹å°äººï¼‰
                if (people.length > 0) {
                    showAnswerBubble(people[0], data.answer);
                }

                // æ¸…ç©ºè¼¸å…¥æ¡†
                questionInput.value = '';
            } catch (error) {
                console.error('Error sending question:', error);
                // é¡¯ç¤ºéŒ¯èª¤è¨Šæ¯
                if (people.length > 0) {
                    showAnswerBubble(people[0], textContent.errorText);
                }
            } finally {
                sendButton.disabled = false;
                sendButton.textContent = textContent.sendButton;
                sendButton.style.background = '#156697';
            }
        }

        // æª¢æŸ¥å°è©±æ³¡æ³¡æ˜¯å¦åœ¨å±å¹•ç¯„åœå…§
        function isBubbleInView(person) {
            const worldPos = new THREE.Vector3();
            person.getWorldPosition(worldPos);
            worldPos.y += 2.4; // æ°£æ³¡åœ¨é ­é ‚ä¸Šæ–¹

            const projected = worldPos.clone().project(camera);
            
            // æª¢æŸ¥æ˜¯å¦åœ¨è¦–éŒé«”å…§ï¼ˆz åœ¨ -1 åˆ° 1 ä¹‹é–“ï¼‰
            if (projected.z < -1 || projected.z > 1) {
                return false;
            }
            
            // æª¢æŸ¥æ˜¯å¦åœ¨å±å¹•ç¯„åœå…§ï¼ˆè€ƒæ…®é‚Šè·ï¼‰
            const margin = 120; // é‚Šè·ï¼ˆåƒç´ ï¼‰ï¼Œå¢åŠ é‚Šè·ç¢ºä¿å®Œå…¨å¯è¦‹
            const x = (projected.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-projected.y * 0.5 + 0.5) * window.innerHeight;
            
            // æª¢æŸ¥æ˜¯å¦åœ¨å±å¹•ç¯„åœå…§ï¼ˆè€ƒæ…®å°è©±æ³¡æ³¡çš„å¯¬åº¦å’Œé«˜åº¦ï¼‰
            const bubbleWidth = 180; // å°è©±æ³¡æ³¡çš„æœ€å¤§å¯¬åº¦
            const bubbleHeight = 80; // å°è©±æ³¡æ³¡çš„ä¼°è¨ˆé«˜åº¦ï¼ˆå¢åŠ ä»¥ç¢ºä¿å®Œå…¨å¯è¦‹ï¼‰
            const topMargin = 150; // é ‚éƒ¨é‚Šè·ï¼ˆåƒç´ ï¼‰ï¼Œç¢ºä¿ä¸æœƒè¶…å‡ºé ‚éƒ¨
            
            return x >= -margin && 
                   x <= window.innerWidth + margin &&
                   y >= topMargin && // ç¢ºä¿æœ‰è¶³å¤ çš„é ‚éƒ¨ç©ºé–“
                   y <= window.innerHeight - margin &&
                   x + bubbleWidth / 2 >= 0 &&
                   x - bubbleWidth / 2 <= window.innerWidth &&
                   y + bubbleHeight / 2 >= 0 &&
                   y - bubbleHeight / 2 <= window.innerHeight;
        }

        // é¡¯ç¤ºå›ç­”çš„å°è©±æ³¡æ³¡
        function showAnswerBubble(person, answer) {
            activeBubblePerson = person;
            bubble.textContent = answer;
            // å…ˆéš±è—ï¼Œç­‰å¾…ç›¸æ©Ÿç§»å‹•åˆ°ä½
            bubble.style.opacity = '0';
            shouldShowBubble = false; // é‡ç½®é¡¯ç¤ºæ¨™è¨˜
            bubbleVisibleUntil = performance.now() + 15000; // é¡¯ç¤º15ç§’ï¼ˆAIå›ç­”é€šå¸¸è¼ƒé•·ï¼‰

            // ä¿å­˜åŸå§‹ç›¸æ©Ÿä½ç½®
            cameraOriginal.radius = cameraRadius;
            cameraOriginal.rotationX = targetRotationX;
            cameraOriginal.rotationY = targetRotationY;
            cameraOriginal.lookAtY = 1;

            // è¨ˆç®—å°äººçš„ä½ç½®å’Œæœå‘
            const personPos = new THREE.Vector3();
            person.getWorldPosition(personPos);
            
            // è¨ˆç®—ç›¸æ©Ÿæ‡‰è©²ç§»å‹•åˆ°çš„ä½ç½®ï¼ˆå¾å´é¢è§’åº¦æ‹æ”ï¼Œé¿å…è¢«ç‰†å£é®æ“‹ï¼‰
            // ç‰†å£åœ¨ z = -6 çš„ä½ç½®ï¼Œå°äººåœ¨ z = -3ï¼ˆæ­£é¢ï¼‰æˆ– z = 3ï¼ˆèƒŒé¢ï¼‰
            // æ”¹ç‚ºå¾å´é¢ï¼ˆå³å´ï¼‰å’Œç¨å¾®åä¸Šçš„è§’åº¦æ‹æ”ï¼Œç¢ºä¿ä¸æœƒè¢«ç‰†å£é®æ“‹
            const personRotation = person.rotation.y;
            
            // ç›¸æ©Ÿæ‡‰è©²åœ¨å°äººçš„å´é¢ï¼Œç¨å¾®åä¸Šï¼Œè·é›¢é©ä¸­ï¼ˆzoom inï¼‰
            const distance = 6; // ç›¸æ©Ÿåˆ°å°äººçš„è·é›¢ï¼ˆzoom inï¼‰
            const height = 2.5; // ç›¸æ©Ÿé«˜åº¦åç§»ï¼ˆç›¸å°æ–¼å°äººï¼Œç¨å¾®å‘ä¸Šçœ‹ï¼Œé¿å…ç‰†å£ï¼‰
            
            // åˆ¤æ–·å°äººçš„ä½ç½®ï¼Œé¸æ“‡åˆé©çš„æ‹æ”è§’åº¦
            // å¦‚æœå°äººåœ¨æ­£é¢ï¼ˆz < 0ï¼‰ï¼Œå¾å³å´æ‹æ”ï¼›å¦‚æœåœ¨èƒŒé¢ï¼Œå¾å·¦å´æ‹æ”
            const isFrontSide = personPos.z < 0;
            const sideOffset = isFrontSide ? Math.PI / 3 : -Math.PI / 3; // 60åº¦è§’ï¼Œå¾å´é¢æ‹æ”
            
            // è¨ˆç®—å´é¢è§’åº¦ï¼ˆå¾å´é¢60åº¦è§’æ‹æ”ï¼Œé¿å…ç‰†å£ï¼‰
            const sideAngle = personRotation + sideOffset;
            
            // è¨ˆç®—ç›¸æ©Ÿç›®æ¨™ä½ç½®ï¼ˆåœ¨å°äººçš„å´å‰æ–¹ï¼Œé¿å…ç‰†å£ï¼‰
            const targetX = personPos.x + Math.sin(sideAngle) * distance;
            const targetZ = personPos.z + Math.cos(sideAngle) * distance;
            const targetY = personPos.y + height;
            
            // è¨ˆç®—ç›¸æ©Ÿæ‡‰è©²çœ‹å‘çš„æ–¹å‘ï¼ˆå°äººçš„é ­éƒ¨ä½ç½®ï¼‰
            const lookAtX = personPos.x;
            const lookAtY = personPos.y + 1.5; // çœ‹å‘å°äººçš„é ­éƒ¨
            const lookAtZ = personPos.z;
            
            // è¨ˆç®—å¾ç›¸æ©Ÿä½ç½®ï¼ˆåŸé»é™„è¿‘ï¼‰åˆ°ç›®æ¨™ä½ç½®çš„å‘é‡
            // ç›¸æ©Ÿçš„åæ¨™ç³»æ˜¯ï¼šåŸé»åœ¨ (0, 8, 0)ï¼Œæ‰€ä»¥éœ€è¦è¨ˆç®—ç›¸å°ä½ç½®
            const dx = targetX - 0;
            const dz = targetZ - 0;
            const dy = targetY - 8; // ç›¸æ©Ÿçš„åŸºç¤é«˜åº¦æ˜¯ 8
            
            // è¨ˆç®—ç›¸æ©Ÿæ—‹è½‰è§’åº¦ï¼ˆè½‰æ›ç‚ºçƒåæ¨™ï¼‰
            const distance2D = Math.sqrt(dx * dx + dz * dz);
            const targetRotY = Math.atan2(dx, dz);
            const targetRotX = Math.atan2(dy, distance2D);
            
            // æª¢æŸ¥æ˜¯å¦æœ‰é è¨­çš„å›ç­”è§’åº¦
            if (window.answerCameraAngles) {
                // ä½¿ç”¨é è¨­çš„è§’åº¦
                cameraTarget.radius = window.answerCameraAngles.radius;
                cameraTarget.rotationX = window.answerCameraAngles.rotationX;
                cameraTarget.rotationY = window.answerCameraAngles.rotationY;
                cameraTarget.lookAtY = window.answerCameraAngles.lookAtY;
                console.log('ä½¿ç”¨é è¨­çš„å›ç­”è§’åº¦:', window.answerCameraAngles);
            } else {
                // ä½¿ç”¨ä½ æä¾›çš„é»˜èªè§’åº¦ï¼ˆé‡å°ç¬¬ä¸€å€‹å°äººï¼‰
                // é€™äº›è§’åº¦æ˜¯å¾ä½ æ‰‹å‹•èª¿æ•´å¾Œç²å–çš„
                const defaultAnswerAngles = {
                    radius: 6.885531693638559,
                    rotationX: -1.0262568468508941,
                    rotationY: 0.7722066350945912,
                    lookAtY: 1.5
                };
                
                cameraTarget.radius = defaultAnswerAngles.radius;
                cameraTarget.rotationX = defaultAnswerAngles.rotationX;
                cameraTarget.rotationY = defaultAnswerAngles.rotationY;
                cameraTarget.lookAtY = defaultAnswerAngles.lookAtY;
                console.log('ä½¿ç”¨é»˜èªçš„å›ç­”è§’åº¦:', defaultAnswerAngles);
            }
            
            // å¦‚æœä¸Šé¢çš„æ¢ä»¶éƒ½ä¸æ»¿è¶³ï¼Œä½¿ç”¨è¨ˆç®—çš„è§’åº¦ï¼ˆä¿ç•™åŸæœ‰é‚è¼¯ä½œç‚ºå‚™ç”¨ï¼‰
            if (false) {
                // è¨ˆç®—ç›¸æ©Ÿåˆ°åŸé»çš„è·é›¢ï¼ˆradiusï¼‰
                const targetRadius = Math.sqrt(dx * dx + dy * dy + dz * dz);
                
                // è¨­ç½®ç›¸æ©Ÿç›®æ¨™
                cameraTarget.radius = targetRadius;
                cameraTarget.rotationX = targetRotX;
                cameraTarget.rotationY = targetRotY;
                cameraTarget.lookAtY = lookAtY;
                
                // æ·»åŠ èª¿è©¦ä¿¡æ¯ï¼ˆå¯é¸ï¼‰
                console.log('Camera moving to person (è¨ˆç®—çš„è§’åº¦):', {
                    personPos: { x: personPos.x, y: personPos.y, z: personPos.z },
                    targetRadius: targetRadius,
                    targetRotX: targetRotX,
                    targetRotY: targetRotY,
                    currentRadius: cameraRadius,
                    currentRotX: targetRotationX,
                    currentRotY: targetRotationY
                });
            }
            
            // å¼·åˆ¶å•Ÿå‹•ç›¸æ©Ÿç§»å‹•
            isCameraMoving = true;

            // ç­‰å¾…ç›¸æ©Ÿç§»å‹•åˆ°ä½ä¸¦æª¢æŸ¥å°è©±æ³¡æ³¡æ˜¯å¦åœ¨ç¯„åœå…§
            // ä½¿ç”¨æŒçºŒæ›´æ–°æ©Ÿåˆ¶ï¼Œåœ¨å‹•ç•«å¾ªç’°ä¸­æ›´æ–°ä½ç½®
            // æ³¨æ„ï¼šä½¿ç”¨å…¨å±€çš„ shouldShowBubbleï¼Œä¸è¦é‡æ–°å£°æ˜
            
            // æŒçºŒæª¢æŸ¥å‡½æ•¸
            function checkAndShowBubble() {
                // æ›´æ–°æ³¡æ³¡ä½ç½®ï¼ˆåœ¨å‹•ç•«å¾ªç’°ä¸­ä¹Ÿæœƒæ›´æ–°ï¼Œé€™è£¡ç¢ºä¿åˆå§‹ä½ç½®æ­£ç¢ºï¼‰
                const worldPos = new THREE.Vector3();
                person.getWorldPosition(worldPos);
                worldPos.y += 2.4; // æŠŠæ°£æ³¡ç§»åˆ°é ­é ‚ä¸Šæ–¹ä¸€é»

                const projected = worldPos.clone().project(camera);
                const x = (projected.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-projected.y * 0.5 + 0.5) * window.innerHeight;

                bubble.style.left = `${x}px`;
                bubble.style.top = `${y - 20}px`;
                
                // æª¢æŸ¥æ˜¯å¦åœ¨ç¯„åœå…§ä¸”ç›¸æ©Ÿå·²ç§»å‹•åˆ°ä½
                const inView = isBubbleInView(person);
                const cameraStopped = !isCameraMoving;
                
                if (inView && cameraStopped) {
                    // å°è©±æ³¡æ³¡åœ¨ç¯„åœå…§ä¸”ç›¸æ©Ÿå·²åœæ­¢ï¼Œæ¨™è¨˜ç‚ºå¯ä»¥é¡¯ç¤º
                    shouldShowBubble = true;
                    bubble.style.opacity = '1';
                } else if (!cameraStopped) {
                    // ç›¸æ©Ÿé‚„åœ¨ç§»å‹•ï¼Œç¹¼çºŒæª¢æŸ¥
                    requestAnimationFrame(checkAndShowBubble);
                } else if (!inView) {
                    // ç›¸æ©Ÿå·²åœæ­¢ä½†ä¸åœ¨ç¯„åœå…§ï¼Œèª¿æ•´ä½ç½®æˆ–å¼·åˆ¶é¡¯ç¤º
                    // å¦‚æœ y ä½ç½®å¤ªé«˜ï¼ˆè¶…å‡ºé ‚éƒ¨ï¼‰ï¼Œèª¿æ•´åˆ°å®‰å…¨ä½ç½®
                    if (y < 150) {
                        bubble.style.top = '150px'; // å¼·åˆ¶è¨­ç½®åˆ°å®‰å…¨ä½ç½®
                    }
                    shouldShowBubble = true;
                    bubble.style.opacity = '1';
                } else {
                    // å…¶ä»–æƒ…æ³ï¼Œç¹¼çºŒæª¢æŸ¥
                    requestAnimationFrame(checkAndShowBubble);
                }
            }
            
            // ç«‹å³é–‹å§‹æª¢æŸ¥ï¼ˆä¸å»¶é²ï¼Œè®“ä½ç½®ç«‹å³æ›´æ–°ï¼‰
            checkAndShowBubble();
            
            // é‡ç½®éš¨æ©Ÿå°è©±çš„æ™‚é–“ï¼Œé¿å…ç«‹å³åˆ‡æ›
            lastBubbleSwitch = performance.now();
            
            // 15ç§’å¾Œæ¢å¾©ç›¸æ©Ÿä½ç½®
            setTimeout(() => {
                cameraTarget.radius = cameraOriginal.radius;
                cameraTarget.rotationX = cameraOriginal.rotationX;
                cameraTarget.rotationY = cameraOriginal.rotationY;
                cameraTarget.lookAtY = cameraOriginal.lookAtY;
                isCameraMoving = true;
            }, 15000);
        }

        // ç™¼é€æŒ‰éˆ•é»æ“Šäº‹ä»¶
        sendButton.addEventListener('click', () => {
            sendQuestion(questionInput.value);
        });

        // Enter éµç™¼é€
        questionInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendQuestion(questionInput.value);
            }
        });

        let activeBubblePerson = null;
        let bubbleVisibleUntil = 0;
        const bubbleDuration = 4000; // æ°£æ³¡é¡¯ç¤º 4 ç§’
        const bubbleInterval = 5500; // ç´„æ¯ 5.5 ç§’éš¨æ©Ÿå‡ºç¾ä¸€æ¬¡
        let lastBubbleSwitch = 0;
        let shouldShowBubble = false; // æ¨™è¨˜æ˜¯å¦æ‡‰è©²é¡¯ç¤ºæ°£æ³¡

        // æ»‘é¼ æ§åˆ¶
        let mouseX = 0;
        let mouseY = 0;
        let targetRotationX = 0;
        let targetRotationY = 0;
        let isMouseDown = false;
        
        // æ·»åŠ å…¨å±€å‡½æ•¸ï¼Œç”¨æ–¼æ‰“å°ç•¶å‰ç›¸æ©Ÿè§’åº¦ä¿¡æ¯
        window.getCameraAngles = function() {
            const personPos = new THREE.Vector3();
            if (people.length > 0) {
                people[0].getWorldPosition(personPos);
            }
            
            const info = {
                cameraRadius: cameraRadius,
                targetRotationX: targetRotationX,
                targetRotationY: targetRotationY,
                cameraPosition: {
                    x: camera.position.x,
                    y: camera.position.y,
                    z: camera.position.z
                },
                personPosition: {
                    x: personPos.x,
                    y: personPos.y,
                    z: personPos.z
                },
                // è¨ˆç®—ç›¸æ©Ÿåˆ°å°äººçš„å‘é‡ï¼ˆç”¨æ–¼è¨­ç½®å›ç­”æ™‚çš„è§’åº¦ï¼‰
                relativeToPerson: {
                    dx: camera.position.x - personPos.x,
                    dy: camera.position.y - personPos.y,
                    dz: camera.position.z - personPos.z
                }
            };
            
            console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            console.log('ğŸ“· ç•¶å‰ç›¸æ©Ÿè§’åº¦ä¿¡æ¯');
            console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            console.log('ç›¸æ©ŸåŠå¾‘ (radius):', info.cameraRadius);
            console.log('ç›¸æ©Ÿæ—‹è½‰ X (rotationX):', info.targetRotationX);
            console.log('ç›¸æ©Ÿæ—‹è½‰ Y (rotationY):', info.targetRotationY);
            console.log('');
            console.log('ç›¸æ©Ÿä½ç½®:', info.cameraPosition);
            console.log('å°äººä½ç½®:', info.personPosition);
            console.log('ç›¸æ©Ÿç›¸å°å°äººä½ç½®:', info.relativeToPerson);
            console.log('');
            console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            console.log('ğŸ“‹ è¤‡è£½ä»¥ä¸‹ JSON çµ¦æˆ‘ä¾†è¨­ç½®å›ç­”è§’åº¦:');
            console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            const answerAngles = {
                radius: info.cameraRadius,
                rotationX: info.targetRotationX,
                rotationY: info.targetRotationY,
                lookAtY: personPos.y + 1.5
            };
            console.log(JSON.stringify(answerAngles, null, 2));
            console.log('');
            console.log('æˆ–è€…ç›´æ¥åœ¨æ§åˆ¶å°åŸ·è¡Œ:');
            console.log(`setAnswerCameraAngles(${JSON.stringify(answerAngles)})`);
            console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
            
            return info;
        };
        
        // æ·»åŠ è¨­ç½®å›ç­”è§’åº¦çš„å‡½æ•¸
        window.setAnswerCameraAngles = function(angles) {
            if (!angles || typeof angles !== 'object') {
                console.error('è«‹æä¾›è§’åº¦å°è±¡ï¼Œæ ¼å¼ï¼š{ radius, rotationX, rotationY, lookAtY }');
                return;
            }
            
            // ä¿å­˜è¨­ç½®çš„è§’åº¦
            window.answerCameraAngles = {
                radius: angles.radius || 10,
                rotationX: angles.rotationX || 0,
                rotationY: angles.rotationY || 0,
                lookAtY: angles.lookAtY || 1.5
            };
            
            console.log('âœ… å›ç­”è§’åº¦å·²è¨­ç½®:', window.answerCameraAngles);
            console.log('ä¸‹æ¬¡å›ç­”æ™‚å°‡ä½¿ç”¨é€™äº›è§’åº¦');
        };
        
        // åœ¨æ§åˆ¶å°æç¤ºç”¨æˆ¶å¯ä»¥ä½¿ç”¨é€™äº›å‡½æ•¸
        // ç¢ºä¿å‡½æ•¸åœ¨å…¨å±€ä½œç”¨åŸŸä¸­å¯ç”¨
        console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        console.log('ğŸ’¡ ç›¸æ©Ÿè§’åº¦æ§åˆ¶å‡½æ•¸å·²å°±ç·’');
        console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        console.log('ä½¿ç”¨æ–¹æ³•ï¼š');
        console.log('  1. æ‰‹å‹•èª¿æ•´ç›¸æ©Ÿåˆ°æƒ³è¦çš„è§’åº¦ï¼ˆæ‹–å‹•é¼ æ¨™æ—‹è½‰ï¼Œæ»¾è¼ªç¸®æ”¾ï¼‰');
        console.log('  2. åœ¨æ§åˆ¶å°è¼¸å…¥ï¼šgetCameraAngles()');
        console.log('  3. è¤‡è£½è¼¸å‡ºçš„ JSON æ ¼å¼è§’åº¦ä¿¡æ¯');
        console.log('  4. æˆ–è€…ç›´æ¥åŸ·è¡Œï¼šsetAnswerCameraAngles({ radius, rotationX, rotationY, lookAtY })');
        console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        
        // é©—è­‰å‡½æ•¸æ˜¯å¦æ­£ç¢ºåŠ è¼‰
        if (typeof window.getCameraAngles === 'function') {
            console.log('âœ… getCameraAngles å‡½æ•¸å·²å°±ç·’ï¼Œå¯ä»¥ç«‹å³ä½¿ç”¨');
        } else {
            console.error('âŒ getCameraAngles å‡½æ•¸æœªæ­£ç¢ºåŠ è¼‰');
        }
        
        if (typeof window.setAnswerCameraAngles === 'function') {
            console.log('âœ… setAnswerCameraAngles å‡½æ•¸å·²å°±ç·’ï¼Œå¯ä»¥ç«‹å³ä½¿ç”¨');
        } else {
            console.error('âŒ setAnswerCameraAngles å‡½æ•¸æœªæ­£ç¢ºåŠ è¼‰');
        }
        
        // å¦‚æœéœ€è¦ï¼Œå¯ä»¥æ‰‹å‹•èª¿ç”¨ getCameraAngles() ä¾†ç²å–è§’åº¦ä¿¡æ¯

        // ç›¸æ©Ÿç¸®æ”¾ï¼ˆè·é›¢ï¼‰æ§åˆ¶
        let cameraRadius = camera.position.length();   // ç›®å‰ç›¸æ©Ÿåˆ°åŸé»çš„è·é›¢
        const minRadius = 10;  // æœ€é è¿‘çš„è·é›¢
        const maxRadius = 22;  // æœ€é çš„è·é›¢
        
        // ç›¸æ©Ÿå¹³æ»‘ç§»å‹•ç‹€æ…‹
        let cameraTarget = {
            radius: cameraRadius,
            rotationX: targetRotationX,
            rotationY: targetRotationY,
            lookAtY: 1
        };
        let cameraOriginal = {
            radius: cameraRadius,
            rotationX: targetRotationX,
            rotationY: targetRotationY,
            lookAtY: 1
        };
        let isCameraMoving = false;
        const cameraMoveSpeed = 0.12; // ç›¸æ©Ÿç§»å‹•é€Ÿåº¦ï¼ˆ0-1ï¼Œè¶Šå¤§è¶Šå¿«ï¼Œä½¿ç”¨æ›´å¿«çš„é€Ÿåº¦æ¸›å°‘å¡é “ï¼‰

        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;

            // å¦‚æœæ»‘é¼ æŒ‰ä¸‹ï¼Œæ—‹è½‰ç›¸æ©Ÿ
            if (isMouseDown) {
                targetRotationY += event.movementX * 0.005;
                targetRotationX += event.movementY * 0.005;
                targetRotationX = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, targetRotationX));
            }
        });

        document.addEventListener('mousedown', () => {
            isMouseDown = true;
        });

        document.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        // æ»¾è¼ªç¸®æ”¾ï¼ˆé™åˆ¶åœ¨æŒ‡å®šè·é›¢ç¯„åœï¼‰
        document.addEventListener('wheel', (event) => {
            event.preventDefault();

            // deltaY > 0 æ»¾è¼ªå¾€ä¸‹ï¼ˆæ‹‰é ï¼‰ï¼ŒdeltaY < 0 æ»¾è¼ªå¾€ä¸Šï¼ˆæ‹‰è¿‘ï¼‰
            cameraRadius += event.deltaY * 0.02;
            cameraRadius = Math.max(minRadius, Math.min(maxRadius, cameraRadius));
        }, { passive: false });

        // è§¸æ§æ”¯æ´
        let touchStartX = 0;
        let touchStartY = 0;

        document.addEventListener('touchstart', (event) => {
            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;
        });

        document.addEventListener('touchmove', (event) => {
            const touch = event.touches[0];
            mouseX = (touch.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(touch.clientY / window.innerHeight) * 2 + 1;

            const deltaX = touch.clientX - touchStartX;
            const deltaY = touch.clientY - touchStartY;

            targetRotationY += deltaX * 0.005;
            targetRotationX += deltaY * 0.005;
            targetRotationX = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, targetRotationX));

            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
        });

        // éŸ¿æ‡‰å¼
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // æ›´æ–°æ‰‹è‡‚åŠ¨ç”»
        let lastAnimationTime = performance.now();
        function updateArmAnimations() {
            const now = performance.now();
            const deltaTime = now - lastAnimationTime;
            lastAnimationTime = now;
            const cycleDuration = 4000; // ä¸€ä¸ªå®Œæ•´å‘¨æœŸï¼ˆæ¯«ç§’ï¼‰

            people.forEach(person => {
                const anim = person.userData.armAnimation;
                if (!anim) return;

                const leftArm = person.userData.leftArm;
                const rightArm = person.userData.rightArm;
                if (!leftArm || !rightArm) return;

                // æ›´æ–°æ—¶é—´
                anim.time += deltaTime;
                
                // ä¸ºå·¦å³æ‰‹è®¾ç½®ä¸åŒçš„æ—¶é—´åç§»ï¼Œé¿å…åŒæ—¶åŠ¨ä½œ
                const leftPhaseOffset = 0; // å·¦æ‰‹åç§»
                const rightPhaseOffset = 0.5; // å³æ‰‹åç§» 50%ï¼Œè¿™æ ·å·¦å³æ‰‹ä¸ä¼šåŒæ—¶åŠ¨ä½œ
                
                const basePhase = (anim.time % cycleDuration) / cycleDuration;
                const leftPhase = (basePhase + leftPhaseOffset) % 1;
                const rightPhase = (basePhase + rightPhaseOffset) % 1;

                // æ›´æ–°æ‰‹è‡‚åŠ¨ç”»
                function updateArm(arm, armType, baseRotationZ, phase) {
                    if (armType === 'none') {
                        // æ— åŠ¨ä½œï¼Œä¿æŒé»˜è®¤ä½ç½®
                        arm.rotation.z = baseRotationZ;
                        arm.rotation.x = 0;
                        return;
                    }

                    // é‡æ–°è®¾è®¡åŠ¨ç”»é˜¶æ®µï¼š
                    // 0-0.1: ä¸¾èµ· (0 -> 1)
                    // 0.1-0.2: ä¿æŒä¸¾èµ· (1)
                    // 0.2-0.3: æ”¾ä¸‹ (1 -> 0)
                    // 0.3-1.0: ä¼‘æ¯/æ”¾ä¸‹ (0)
                    let animAmount = 0;
                    if (phase < 0.1) {
                        // ä¸¾èµ·é˜¶æ®µï¼š0 åˆ° 1
                        animAmount = phase / 0.1;
                    } else if (phase < 0.2) {
                        // ä¿æŒä¸¾èµ·ï¼š1
                        animAmount = 1;
                    } else if (phase < 0.3) {
                        // æ”¾ä¸‹é˜¶æ®µï¼š1 åˆ° 0
                        animAmount = 1 - (phase - 0.2) / 0.1;
                    } else {
                        // ä¼‘æ¯é˜¶æ®µï¼š0ï¼ˆæ‰‹æ”¾ä¸‹ï¼‰
                        animAmount = 0;
                    }

                    switch (armType) {
                        case 'raise': {
                            // ä¸¾èµ·åˆæ”¾ä¸‹
                            const raiseAmount = animAmount * 1.2; // 0 åˆ° 1.2 å¼§åº¦
                            // å·¦æ‰‹ï¼ˆbaseRotationZ > 0ï¼‰æ—¶å¢åŠ ï¼Œå³æ‰‹ï¼ˆbaseRotationZ < 0ï¼‰æ—¶å‡å°‘
                            arm.rotation.z = baseRotationZ + (baseRotationZ > 0 ? raiseAmount : -raiseAmount);
                            arm.rotation.x = 0;
                            break;
                        }
                        case 'spread': {
                            // å‘å¤–å¼ å¼€åˆåˆèµ·æ¥
                            const spreadAmount = animAmount * 0.8; // 0 åˆ° 0.8 å¼§åº¦
                            // å·¦æ‰‹ï¼ˆbaseRotationZ > 0ï¼‰æ—¶å¢åŠ ï¼Œå³æ‰‹ï¼ˆbaseRotationZ < 0ï¼‰æ—¶å‡å°‘
                            arm.rotation.z = baseRotationZ + (baseRotationZ > 0 ? spreadAmount : -spreadAmount);
                            arm.rotation.x = 0;
                            break;
                        }
                        case 'point': {
                            // å‘å‰æŒ‡åˆæ”¾ä¸‹
                            const pointAmount = animAmount * 0.6;
                            // å‘å‰æŒ‡éœ€è¦è°ƒæ•´ z æ—‹è½¬ï¼ˆå‘å‰ï¼‰å’Œ x æ—‹è½¬ï¼ˆå‘ä¸‹å€¾æ–œï¼‰
                            arm.rotation.z = baseRotationZ - pointAmount * 0.5;
                            arm.rotation.x = pointAmount * 0.8; // å‘å‰å€¾æ–œ
                            break;
                        }
                    }
                }

                // æ›´æ–°å·¦å³æ‰‹ï¼ˆå·¦æ‰‹åŸºç¡€æ—‹è½¬æ˜¯ 0.3ï¼Œå³æ‰‹æ˜¯ -0.3ï¼‰
                // ä½¿ç”¨ä¸åŒçš„ phase åç§»ï¼Œè®©å·¦å³æ‰‹ä¸ä¼šåŒæ—¶åŠ¨ä½œ
                updateArm(leftArm, anim.leftArm, 0.3, leftPhase);
                updateArm(rightArm, anim.rightArm, -0.3, rightPhase);
            });
        }

        // æ›´æ–°çœ¼ç›ä½ç½®
        function updateEyes() {
            // å‰µå»ºä¸€å€‹è™›æ“¬çš„æ»‘é¼ ä½ç½®é»
            const vector = new THREE.Vector3(mouseX, mouseY, 0.5);
            vector.unproject(camera);
            
            const dir = vector.sub(camera.position).normalize();
            const distance = -camera.position.y / dir.y;
            const pos = camera.position.clone().add(dir.multiplyScalar(distance));

            people.forEach(person => {
                const eyes = person.userData.eyes;
                if (eyes) {
                    eyes.forEach(eye => {
                        const pupil = eye.userData.pupil;
                        if (pupil) {
                            // è¨ˆç®—çœ¼ç›çœ‹å‘æ»‘é¼ çš„æ–¹å‘
                            const eyeWorldPos = new THREE.Vector3();
                            eye.getWorldPosition(eyeWorldPos);

                            const lookDir = new THREE.Vector3()
                                .subVectors(pos, eyeWorldPos)
                                .normalize();

                            // å°‡æ–¹å‘è½‰æ›ç‚ºçœ¼ç›çš„å±€éƒ¨åæ¨™
                            const localDir = eye.worldToLocal(lookDir.clone().add(eyeWorldPos))
                                .sub(eye.worldToLocal(eyeWorldPos.clone()));

                            // é™åˆ¶ç³å­”ç§»å‹•ç¯„åœ
                            const maxDistance = 0.06;
                            const distance = Math.min(maxDistance, localDir.length());
                            localDir.normalize().multiplyScalar(distance);

                            pupil.position.x = localDir.x;
                            pupil.position.y = localDir.y;
                        }
                    });
                }
            });
        }

        // å°è©±æ°£æ³¡æ›´æ–°ï¼ˆéš¨æ©Ÿé¸ä¸€å€‹äººã€éš¨æ©Ÿä¸€å¥è©±ï¼‰
        function updateSpeechBubble() {
            const now = performance.now();

            // å¦‚æœç›®å‰æ²’æœ‰æ°£æ³¡æˆ–æ™‚é–“åˆ°äº†ï¼Œå˜—è©¦åˆ‡æ›åˆ°ä¸‹ä¸€å€‹
            if (!activeBubblePerson || now > bubbleVisibleUntil) {
                if (now - lastBubbleSwitch < bubbleInterval) {
                    // é‚„æ²’åˆ°ä¸‹ä¸€æ¬¡é¡¯ç¤ºæ™‚é–“ï¼Œéš±è—æ°£æ³¡
                    bubble.style.opacity = '0';
                    activeBubblePerson = null;
                    return;
                }

                const candidates = people.filter(p => Array.isArray(p.userData.messages) && p.userData.messages.length > 0);
                if (candidates.length === 0) {
                    bubble.style.opacity = '0';
                    activeBubblePerson = null;
                    return;
                }

                const person = candidates[Math.floor(Math.random() * candidates.length)];
                const msgs = person.userData.messages;
                const msg = msgs[Math.floor(Math.random() * msgs.length)];

                activeBubblePerson = person;
                bubble.textContent = msg;
                bubbleVisibleUntil = now + bubbleDuration;
                lastBubbleSwitch = now;
                bubble.style.opacity = '1';
            }

            // å¦‚æœæœ‰æ­£åœ¨é¡¯ç¤ºçš„æ°£æ³¡ï¼Œæ›´æ–°å…¶è¢å¹•åº§æ¨™
            if (activeBubblePerson) {
                const worldPos = new THREE.Vector3();
                activeBubblePerson.getWorldPosition(worldPos);
                worldPos.y += 2.4; // æŠŠæ°£æ³¡ç§»åˆ°é ­é ‚ä¸Šæ–¹ä¸€é»

                const projected = worldPos.clone().project(camera);
                let x = (projected.x * 0.5 + 0.5) * window.innerWidth;
                let y = (-projected.y * 0.5 + 0.5) * window.innerHeight;

                // ç¢ºä¿æ°£æ³¡ä¸æœƒè¶…å‡ºé ‚éƒ¨ç¯„åœ
                const minTop = 150; // æœ€å°é ‚éƒ¨ä½ç½®
                if (y < minTop) {
                    y = minTop;
                }
                
                // ç¢ºä¿æ°£æ³¡ä¸æœƒè¶…å‡ºå·¦å³é‚Šç•Œ
                const bubbleWidth = 180;
                const margin = 20;
                if (x - bubbleWidth / 2 < margin) {
                    x = margin + bubbleWidth / 2;
                } else if (x + bubbleWidth / 2 > window.innerWidth - margin) {
                    x = window.innerWidth - margin - bubbleWidth / 2;
                }

                bubble.style.left = `${x}px`;
                bubble.style.top = `${y - 20}px`;
                
                // å¦‚æœå°è©±æ³¡æ³¡åœ¨ç¯„åœå…§ï¼Œç¢ºä¿å®ƒæ˜¯å¯è¦‹çš„
                if (isBubbleInView(activeBubblePerson) || shouldShowBubble) {
                    bubble.style.opacity = '1';
                } else if (isCameraMoving) {
                    // å¦‚æœç›¸æ©Ÿé‚„åœ¨ç§»å‹•ä¸”é‚„æ²’æ¨™è¨˜ç‚ºå¯é¡¯ç¤ºï¼Œæš«æ™‚éš±è—
                    bubble.style.opacity = '0';
                }
            }
        }

        // å‹•ç•«å¾ªç’°
        function animate() {
            requestAnimationFrame(animate);

            // å¹³æ»‘ç§»å‹•ç›¸æ©Ÿåˆ°ç›®æ¨™ä½ç½®ï¼ˆä½¿ç”¨ç·©å‹•å‡½æ•¸æ¸›å°‘å¡é “ï¼‰
            if (isCameraMoving) {
                const radiusDiff = cameraTarget.radius - cameraRadius;
                const rotXDiff = cameraTarget.rotationX - targetRotationX;
                const rotYDiff = cameraTarget.rotationY - targetRotationY;
                
                // è¨ˆç®—è·é›¢ï¼Œä½¿ç”¨æ›´å¯¬é¬†çš„åœæ­¢æ¢ä»¶
                const radiusDist = Math.abs(radiusDiff);
                const rotXDist = Math.abs(rotXDiff);
                const rotYDist = Math.abs(rotYDiff);
                
                // å¦‚æœè·é›¢ç›®æ¨™å¾ˆè¿‘ï¼Œåœæ­¢ç§»å‹•
                if (radiusDist < 0.15 && rotXDist < 0.015 && rotYDist < 0.015) {
                    cameraRadius = cameraTarget.radius;
                    targetRotationX = cameraTarget.rotationX;
                    targetRotationY = cameraTarget.rotationY;
                    isCameraMoving = false;
                } else {
                    // ä½¿ç”¨è‡ªé©æ‡‰é€Ÿåº¦ï¼šè·é›¢è¶Šé ï¼Œç§»å‹•è¶Šå¿«ï¼ˆä½†æœ‰é™åˆ¶ï¼‰
                    const adaptiveSpeed = Math.min(cameraMoveSpeed * (1 + radiusDist * 0.15), 0.2);
                    
                    // å¹³æ»‘æ’å€¼ç§»å‹•
                    cameraRadius += radiusDiff * adaptiveSpeed;
                    targetRotationX += rotXDiff * adaptiveSpeed;
                    targetRotationY += rotYDiff * adaptiveSpeed;
                    
                    // ç¢ºä¿ç›¸æ©Ÿç¢ºå¯¦ç§»å‹•äº†
                    if (Math.abs(radiusDiff) > 0.01 || Math.abs(rotXDiff) > 0.001 || Math.abs(rotYDiff) > 0.001) {
                        // ç›¸æ©Ÿæ­£åœ¨ç§»å‹•ï¼Œç¹¼çºŒ
                    }
                }
            }

            // å¹³æ»‘æ—‹è½‰ç›¸æ©Ÿï¼ˆä½¿ç”¨å—é™åˆ¶çš„ cameraRadiusï¼‰
            const radius = cameraRadius;
            camera.position.x = radius * Math.sin(targetRotationY) * Math.cos(targetRotationX);
            camera.position.y = radius * Math.sin(targetRotationX) + 8;
            camera.position.z = radius * Math.cos(targetRotationY) * Math.cos(targetRotationX);
            
            // å¦‚æœæ­£åœ¨ç§»å‹•åˆ°å°äººï¼Œçœ‹å‘å°äººçš„ä½ç½®ï¼›å¦å‰‡çœ‹å‘åŸé»
            if (isCameraMoving && activeBubblePerson) {
                const personPos = new THREE.Vector3();
                activeBubblePerson.getWorldPosition(personPos);
                camera.lookAt(personPos.x, cameraTarget.lookAtY, personPos.z);
            } else {
                camera.lookAt(0, 1, 0);
            }

            // æ›´æ–°æ‰‹è‡‚åŠ¨ç”»
            updateArmAnimations();

            // æ›´æ–°çœ¼ç›
            updateEyes();

            // æ›´æ–°å°è©±æ°£æ³¡
            updateSpeechBubble();

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>


