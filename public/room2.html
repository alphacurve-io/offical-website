<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Alphacurve.io Meeting Room</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: #f0f0f0;
        }

        canvas {
            display: block;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #333;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        #info h3 {
            margin: 0 0 10px 0;
            color: #1a73e8;
        }
    </style>
</head>
<body>
    <!-- <div id="info">
        <h3>ğŸ§± Alphacurve.io Meeting Room</h3>
        <p>Drag mouse to rotate view</p>
        <p>Scroll wheel to zoom</p>
    </div> -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // å¾ URL åƒæ•¸è®€å–è‡ªè¨‚äººç‰©è¨­å®šï¼ˆç”± React å‚³å…¥ï¼‰
        // people = encodeURIComponent(JSON.stringify([{ bodyColor, hairColor, expression }, ...]))
        function getCustomPeopleConfigs() {
            try {
                const params = new URLSearchParams(window.location.search);
                const raw = params.get('people');
                if (!raw) return null;
                const decoded = decodeURIComponent(raw);
                const parsed = JSON.parse(decoded);
                if (!Array.isArray(parsed)) return null;
                return parsed;
            } catch (e) {
                console.warn('Failed to parse custom people config:', e);
                return null;
            }
        }

        // å¾ URL è®€å–ç™½æ¿æ¨™é¡Œï¼ˆç”± React å‚³å…¥ï¼‰
        function getBoardTitle() {
            try {
                const params = new URLSearchParams(window.location.search);
                const raw = params.get('title');
                if (!raw) return null;
                return decodeURIComponent(raw);
            } catch (e) {
                console.warn('Failed to parse board title:', e);
                return null;
            }
        }

        function hexToColorNumber(hex, fallback) {
            if (!hex || typeof hex !== 'string') return fallback;
            const cleaned = hex.replace('#', '');
            const num = parseInt(cleaned, 16);
            return Number.isNaN(num) ? fallback : num;
        }

        // å ´æ™¯è¨­ç½®
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);

        // ç›¸æ©Ÿ
        const camera = new THREE.PerspectiveCamera(
            45,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 8, 15);
        camera.lookAt(0, 0, 0);

        // æ¸²æŸ“å™¨
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // å…‰æº
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -10;
        directionalLight.shadow.camera.right = 10;
        directionalLight.shadow.camera.top = 10;
        directionalLight.shadow.camera.bottom = -10;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // åœ°æ¿
        const floorGeometry = new THREE.PlaneGeometry(30, 30);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xe0e0e0,
            roughness: 0.8,
            metalness: 0.2
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -0.5;
        floor.receiveShadow = true;
        scene.add(floor);

        // å‰µå»ºæœ¨ç´‹ç´‹ç†
        function createWoodTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // åŸºç¤æœ¨è‰²
            ctx.fillStyle = '#8B6F47';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // æœ¨ç´‹æ¢ç´‹æ•ˆæœ
            for (let i = 0; i < canvas.width; i += 2) {
                const noise = Math.sin(i * 0.05) * 3;
                const brightness = 50 + Math.sin(i * 0.1) * 20;
                ctx.fillStyle = `rgba(${139 + brightness}, ${111 + brightness * 0.7}, ${71 + brightness * 0.5}, 0.3)`;
                ctx.fillRect(i, 0, 2, canvas.height);
            }

            // æ·»åŠ æœ¨ç´‹ç´°ç¯€
            for (let i = 0; i < 50; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const w = 1 + Math.random() * 2;
                const h = canvas.height;
                const alpha = 0.1 + Math.random() * 0.2;
                ctx.fillStyle = `rgba(${100 + Math.random() * 50}, ${80 + Math.random() * 40}, ${50 + Math.random() * 30}, ${alpha})`;
                ctx.fillRect(x, y, w, h);
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(2, 1); // æ©«å‘é‡è¤‡ï¼Œè®“æœ¨ç´‹æ›´è‡ªç„¶
            return texture;
        }

        // å‰µå»ºæœƒè­°æ¡Œ
        function createTable() {
            const table = new THREE.Group();

            // æ¡Œé¢ - ä½¿ç”¨æœ¨ç´‹æè³ª
            const topGeometry = new THREE.BoxGeometry(6, 0.2, 4);
            const woodTexture = createWoodTexture();
            const topMaterial = new THREE.MeshStandardMaterial({ 
                map: woodTexture,
                roughness: 0.7,
                metalness: 0.1
            });
            const top = new THREE.Mesh(topGeometry, topMaterial);
            top.position.y = 1;
            top.castShadow = true;
            top.receiveShadow = true;
            table.add(top);

            // æ¡Œè…³
            const legGeometry = new THREE.BoxGeometry(0.15, 1, 0.15);
            const legMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xcccccc,
                roughness: 0.5
            });

            const legPositions = [
                [-2.5, 0.5, -1.5],
                [2.5, 0.5, -1.5],
                [-2.5, 0.5, 1.5],
                [2.5, 0.5, 1.5]
            ];

            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                leg.position.set(...pos);
                leg.castShadow = true;
                table.add(leg);
            });

            // æ¡Œä¸Šç‰©å“ - ç­†è¨˜å‹é›»è…¦
            const laptopBase = new THREE.BoxGeometry(0.6, 0.05, 0.4);
            const laptopScreen = new THREE.BoxGeometry(0.6, 0.5, 0.05);
            const laptopMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            
            const laptop = new THREE.Group();
            const base = new THREE.Mesh(laptopBase, laptopMaterial);
            base.position.y = 1.15;
            const screen = new THREE.Mesh(laptopScreen, laptopMaterial);
            screen.position.set(0, 1.4, -0.15);
            screen.rotation.x = -0.3;
            laptop.add(base, screen);
            laptop.position.set(-1.5, 0, 0);
            table.add(laptop);

            // æ–‡ä»¶
            const docGeometry = new THREE.BoxGeometry(0.3, 0.02, 0.4);
            const docMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const document = new THREE.Mesh(docGeometry, docMaterial);
            document.position.set(1.5, 1.12, 0.5);
            table.add(document);

            // æ‰‹æ©Ÿ
            const phoneGeometry = new THREE.BoxGeometry(0.15, 0.02, 0.25);
            const phoneMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const phone = new THREE.Mesh(phoneGeometry, phoneMaterial);
            phone.position.set(0.8, 1.12, -0.8);
            table.add(phone);

            return table;
        }

        // å‰µå»ºæ¨‚é«˜äººç‰©
        // expression: 'neutral' | 'smile' | 'sad' | 'surprised'
        function createLegoPerson(bodyColor, hairColor, expression = 'neutral') {
            const person = new THREE.Group();

            // èº«é«”
            const bodyGeometry = new THREE.BoxGeometry(0.8, 1.2, 0.6);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: bodyColor,
                roughness: 0.4
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.6;
            body.castShadow = true;
            person.add(body);

            // é ­éƒ¨
            const headGeometry = new THREE.BoxGeometry(0.7, 0.8, 0.7);
            const headMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffd700,
                roughness: 0.3
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.5;
            head.castShadow = true;
            person.add(head);

            // é ­é«®
            const hairGeometry = new THREE.BoxGeometry(0.72, 0.3, 0.72);
            const hairMaterial = new THREE.MeshStandardMaterial({ 
                color: hairColor,
                roughness: 0.6
            });
            const hair = new THREE.Mesh(hairGeometry, hairMaterial);
            hair.position.y = 2.05;
            hair.castShadow = true;
            person.add(hair);

            // çœ¼ç›å®¹å™¨
            const eyesGroup = new THREE.Group();
            eyesGroup.position.set(0, 1.6, 0.36);

            // å·¦çœ¼
            const leftEye = createEye();
            leftEye.position.x = -0.2;
            eyesGroup.add(leftEye);

            // å³çœ¼
            const rightEye = createEye();
            rightEye.position.x = 0.2;
            eyesGroup.add(rightEye);

            person.add(eyesGroup);
            person.userData.eyes = [leftEye, rightEye];

            // å˜´å·´ï¼ˆè¡¨æƒ…ï¼‰
            let mouth;
            if (expression === 'surprised') {
                // é©šè¨ï¼šåœ“å½¢å˜´å·´
                const mouthGeometry = new THREE.CircleGeometry(0.11, 28);
                const mouthMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x000000,
                    side: THREE.DoubleSide
                });
                mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
                mouth.position.set(0, 1.34, 0.37);
            } else if (expression === 'smile') {
                // ç¬‘è‡‰ï¼šä½¿ç”¨å¼§å½¢ Shape å¹¾ä½•åšå‡ºçœŸæ­£çš„å¾®ç¬‘æ›²ç·š
                const width = 0.6;
                const height = 0.16;
                const thickness = 0.05;

                const smileShape = new THREE.Shape();
                // å¤–å¼§ç·šï¼ˆå¾€ä¸‹å½ï¼‰
                smileShape.moveTo(-width / 2, 0);
                smileShape.quadraticCurveTo(0, -height, width / 2, 0);
                // å…§å¼§ç·šï¼ˆå¾€ä¸‹å½ï¼Œç¨å¾®é ä¸Šå½¢æˆå¼§å½¢æ¢å¸¶ï¼‰
                const innerOffset = 0.04;
                smileShape.lineTo(width / 2, innerOffset);
                smileShape.quadraticCurveTo(0, -height + innerOffset, -width / 2, innerOffset);
                smileShape.closePath();

                const mouthGeometry = new THREE.ShapeGeometry(smileShape, 24);
                const mouthMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xff4444,
                    emissive: 0x330000,
                    emissiveIntensity: 0.4
                });
                mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
                mouth.position.set(0, 1.36, 0.36 + thickness / 2);
            } else if (expression === 'sad') {
                // é›£éï¼šæ¯”è¼ƒçŸ­ã€ç•¥é«˜ã€é¡è‰²åæ·±
                const mouthGeometry = new THREE.BoxGeometry(0.28, 0.05, 0.05);
                const mouthMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x111111
                });
                mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
                mouth.position.set(0, 1.49, 0.36);
            } else {
                // ä¸­æ€§è¡¨æƒ…
                const mouthGeometry = new THREE.BoxGeometry(0.35, 0.05, 0.05);
                const mouthMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x000000
                });
                mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
                mouth.position.set(0, 1.41, 0.36);
            }
            person.add(mouth);

            // æ‰‹è‡‚
            const armGeometry = new THREE.BoxGeometry(0.2, 0.8, 0.2);
            const armMaterial = new THREE.MeshStandardMaterial({ 
                color: bodyColor,
                roughness: 0.4
            });

            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.5, 0.8, 0);
            leftArm.rotation.z = 0.3;
            leftArm.castShadow = true;
            person.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.5, 0.8, 0);
            rightArm.rotation.z = -0.3;
            rightArm.castShadow = true;
            person.add(rightArm);

            return person;
        }

        // å‰µå»ºçœ¼ç›
        function createEye() {
            const eyeGroup = new THREE.Group();

            // çœ¼ç™½
            const whiteGeometry = new THREE.CircleGeometry(0.12, 16);
            const whiteMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffffff,
                side: THREE.DoubleSide
            });
            const white = new THREE.Mesh(whiteGeometry, whiteMaterial);
            eyeGroup.add(white);

            // çœ¼ç ï¼ˆå¯ç§»å‹•ï¼‰
            const pupilGeometry = new THREE.CircleGeometry(0.05, 16);
            const pupilMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x000000,
                side: THREE.DoubleSide
            });
            const pupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            pupil.position.z = 0.01;
            eyeGroup.add(pupil);

            eyeGroup.userData.pupil = pupil;

            return eyeGroup;
        }

        // æ·»åŠ æœƒè­°æ¡Œ
        const table = createTable();
        scene.add(table);

        // æ·»åŠ äººç‰©
        const people = [];

        const defaultPersonConfigs = [
            // æ­£é¢ä¸‰äºº
            { pos: [-3, 0, -3], rot: 0.5, body: 0x2c5f2d, hair: 0x654321, expression: 'smile' },
            { pos: [0, 0, -3], rot: 0, body: 0x1e3a5f, hair: 0xffd700, expression: 'surprised' },
            { pos: [3, 0, -3], rot: -0.5, body: 0x1a1a4e, hair: 0x8b4513, expression: 'neutral' },
            // èƒŒé¢ä¸‰äºº
            { pos: [-3, 0, 3], rot: 2.6, body: 0x1a1a4e, hair: 0x8b4513, expression: 'sad' },
            { pos: [0, 0, 3], rot: Math.PI, body: 0x2c5f2d, hair: 0xffa500, expression: 'smile' },
            { pos: [3, 0, 3], rot: -2.6, body: 0x1e3a5f, hair: 0x654321, expression: 'neutral' }
        ];

        const externalPeople = getCustomPeopleConfigs();

        const personConfigs = defaultPersonConfigs.map((cfg, index) => {
            const override = externalPeople && externalPeople[index] ? externalPeople[index] : {};
            return {
                ...cfg,
                body: hexToColorNumber(override.bodyColor, cfg.body),
                hair: hexToColorNumber(override.hairColor, cfg.hair),
                expression: override.expression || cfg.expression,
                messages: Array.isArray(override.messages) ? override.messages : (cfg.messages || []),
            };
        });

        personConfigs.forEach(config => {
            const person = createLegoPerson(config.body, config.hair, config.expression);
            person.position.set(...config.pos);
            person.rotation.y = config.rot;
            person.userData.messages = config.messages || [];
            scene.add(person);
            people.push(person);
        });

        // ç‰†å£èˆ‡ç™½æ¿
        function createWalls() {
            const walls = new THREE.Group();

            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffffff,
                roughness: 0.6
            });

            // åƒ…ä¿ç•™å¾Œæ–¹é€™é¢ç‰†ï¼ˆå…¶ä»–å´ç‰†ç§»é™¤ï¼‰
            const backWallGeometry = new THREE.BoxGeometry(12, 5, 0.2);
            const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
            backWall.position.set(0, 2, -6);
            backWall.receiveShadow = true;
            walls.add(backWall);

            // ç™½æ¿
            const boardGeometry = new THREE.BoxGeometry(5, 2.5, 0.1);
            const boardMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xf5f5f5,
                emissive: 0xffffff,
                emissiveIntensity: 0.1
            });
            const board = new THREE.Mesh(boardGeometry, boardMaterial);
            board.position.set(0, 3, -5.89);
            board.receiveShadow = true;
            walls.add(board);

            // ç™½æ¿æ¨™é¡Œï¼ˆå¾ URL content å‚³å…¥ï¼‰
            const boardTitle = getBoardTitle();
            if (boardTitle) {
                const canvas = document.createElement('canvas');
                canvas.width = 1024;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');

                // èƒŒæ™¯é€æ˜
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // æ–‡å­—æ¨£å¼
                ctx.font = 'bold 80px Arial, system-ui, -apple-system, BlinkMacSystemFont';
                ctx.fillStyle = '#156697';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(boardTitle, canvas.width / 2, canvas.height / 2);

                const titleTexture = new THREE.CanvasTexture(canvas);
                titleTexture.needsUpdate = true;

                const titleWidth = 2.5;
                const titleHeight = titleWidth * (canvas.height / canvas.width);
                const titleGeo = new THREE.PlaneGeometry(titleWidth, titleHeight);
                const titleMat = new THREE.MeshBasicMaterial({
                    map: titleTexture,
                    transparent: true,
                    side: THREE.DoubleSide
                });
                const titleMesh = new THREE.Mesh(titleGeo, titleMat);
                // æ”¾åœ¨ header-icon ä¸Šæ–¹ä¸€äº›
                titleMesh.position.set(0, 0.9, 0.061);
                board.add(titleMesh);
            }

            // åœ¨ç™½æ¿ä¸­å¤®è²¼ä¸Š Alphacurve header icon åœ–ç‰‡
            // SVG å°ºå¯¸ç´„ 40x37ï¼Œé€™è£¡ç”¨ç›¸åŒé•·å¯¬æ¯”å»ºç«‹å¹³é¢
            const logoAspect = 37 / 40;
            const logoWidth = 0.8;
            const logoHeight = logoWidth * logoAspect;

            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(
                '/header-icon.svg',
                (texture) => {
                    // è¨­ç½®ç´‹ç†åƒæ•¸ä»¥ç¢ºä¿ SVG æ­£ç¢ºé¡¯ç¤º
                    texture.flipY = false;
                    texture.needsUpdate = true;
                    
                    const logoGeo = new THREE.PlaneGeometry(logoWidth, logoHeight);
                    const logoMat = new THREE.MeshBasicMaterial({
                        map: texture,
                        transparent: true,
                        side: THREE.DoubleSide
                    });
                    const logoMesh = new THREE.Mesh(logoGeo, logoMat);
                    // åœ¨ç™½æ¿çš„å±€éƒ¨åæ¨™ç³»ä¸­ï¼Œç¨å¾®å¾€å‰ç§»ï¼Œé¿å… Z-fighting
                    // ç™½æ¿é¢å‘ +Z æ–¹å‘ï¼Œæ‰€ä»¥ logo æ‡‰è©²åœ¨ +Z æ–¹å‘
                    logoMesh.position.set(0, 0, 0.06);
                    // ç›®å‰ç´‹ç†é¡¯ç¤ºä¸Šä¸‹é¡›å€’ï¼Œå°‡å¹³é¢ç¹ X è»¸æ—‹è½‰ 180 åº¦è½‰æ­£
                    logoMesh.rotation.x = Math.PI;
                    board.add(logoMesh);
                },
                undefined,
                (err) => {
                    console.warn('Failed to load header-icon.svg texture', err);
                }
            );

            return walls;
        }

        const walls = createWalls();
        scene.add(walls);

        // å°è©±æ°£æ³¡ï¼ˆHTML overlayï¼‰
        const bubble = document.createElement('div');
        bubble.className = 'room2-speech-bubble';
        bubble.style.position = 'fixed';
        bubble.style.zIndex = '10';
        bubble.style.padding = '6px 10px';
        bubble.style.borderRadius = '12px';
        bubble.style.background = 'rgba(0, 0, 0, 0.7)';
        bubble.style.color = '#fff';
        bubble.style.fontSize = '11px';
        bubble.style.fontFamily = 'Inter, system-ui, -apple-system, BlinkMacSystemFont, sans-serif';
        bubble.style.maxWidth = '180px';
        bubble.style.pointerEvents = 'none';
        bubble.style.boxShadow = '0 2px 8px rgba(0,0,0,0.35)';
        bubble.style.opacity = '0';
        bubble.style.transition = 'opacity 0.3s ease';
        document.body.appendChild(bubble);

        let activeBubblePerson = null;
        let bubbleVisibleUntil = 0;
        const bubbleDuration = 4000; // æ°£æ³¡é¡¯ç¤º 4 ç§’
        const bubbleInterval = 5500; // ç´„æ¯ 5.5 ç§’éš¨æ©Ÿå‡ºç¾ä¸€æ¬¡
        let lastBubbleSwitch = 0;

        // æ»‘é¼ æ§åˆ¶
        let mouseX = 0;
        let mouseY = 0;
        let targetRotationX = 0;
        let targetRotationY = 0;
        let isMouseDown = false;

        // ç›¸æ©Ÿç¸®æ”¾ï¼ˆè·é›¢ï¼‰æ§åˆ¶
        let cameraRadius = camera.position.length();   // ç›®å‰ç›¸æ©Ÿåˆ°åŸé»çš„è·é›¢
        const minRadius = 10;  // æœ€é è¿‘çš„è·é›¢
        const maxRadius = 22;  // æœ€é çš„è·é›¢

        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;

            // å¦‚æœæ»‘é¼ æŒ‰ä¸‹ï¼Œæ—‹è½‰ç›¸æ©Ÿ
            if (isMouseDown) {
                targetRotationY += event.movementX * 0.005;
                targetRotationX += event.movementY * 0.005;
                targetRotationX = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, targetRotationX));
            }
        });

        document.addEventListener('mousedown', () => {
            isMouseDown = true;
        });

        document.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        // æ»¾è¼ªç¸®æ”¾ï¼ˆé™åˆ¶åœ¨æŒ‡å®šè·é›¢ç¯„åœï¼‰
        document.addEventListener('wheel', (event) => {
            event.preventDefault();

            // deltaY > 0 æ»¾è¼ªå¾€ä¸‹ï¼ˆæ‹‰é ï¼‰ï¼ŒdeltaY < 0 æ»¾è¼ªå¾€ä¸Šï¼ˆæ‹‰è¿‘ï¼‰
            cameraRadius += event.deltaY * 0.02;
            cameraRadius = Math.max(minRadius, Math.min(maxRadius, cameraRadius));
        }, { passive: false });

        // è§¸æ§æ”¯æ´
        let touchStartX = 0;
        let touchStartY = 0;

        document.addEventListener('touchstart', (event) => {
            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;
        });

        document.addEventListener('touchmove', (event) => {
            const touch = event.touches[0];
            mouseX = (touch.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(touch.clientY / window.innerHeight) * 2 + 1;

            const deltaX = touch.clientX - touchStartX;
            const deltaY = touch.clientY - touchStartY;

            targetRotationY += deltaX * 0.005;
            targetRotationX += deltaY * 0.005;
            targetRotationX = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, targetRotationX));

            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
        });

        // éŸ¿æ‡‰å¼
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // æ›´æ–°çœ¼ç›ä½ç½®
        function updateEyes() {
            // å‰µå»ºä¸€å€‹è™›æ“¬çš„æ»‘é¼ ä½ç½®é»
            const vector = new THREE.Vector3(mouseX, mouseY, 0.5);
            vector.unproject(camera);
            
            const dir = vector.sub(camera.position).normalize();
            const distance = -camera.position.y / dir.y;
            const pos = camera.position.clone().add(dir.multiplyScalar(distance));

            people.forEach(person => {
                const eyes = person.userData.eyes;
                if (eyes) {
                    eyes.forEach(eye => {
                        const pupil = eye.userData.pupil;
                        if (pupil) {
                            // è¨ˆç®—çœ¼ç›çœ‹å‘æ»‘é¼ çš„æ–¹å‘
                            const eyeWorldPos = new THREE.Vector3();
                            eye.getWorldPosition(eyeWorldPos);

                            const lookDir = new THREE.Vector3()
                                .subVectors(pos, eyeWorldPos)
                                .normalize();

                            // å°‡æ–¹å‘è½‰æ›ç‚ºçœ¼ç›çš„å±€éƒ¨åæ¨™
                            const localDir = eye.worldToLocal(lookDir.clone().add(eyeWorldPos))
                                .sub(eye.worldToLocal(eyeWorldPos.clone()));

                            // é™åˆ¶ç³å­”ç§»å‹•ç¯„åœ
                            const maxDistance = 0.06;
                            const distance = Math.min(maxDistance, localDir.length());
                            localDir.normalize().multiplyScalar(distance);

                            pupil.position.x = localDir.x;
                            pupil.position.y = localDir.y;
                        }
                    });
                }
            });
        }

        // å°è©±æ°£æ³¡æ›´æ–°ï¼ˆéš¨æ©Ÿé¸ä¸€å€‹äººã€éš¨æ©Ÿä¸€å¥è©±ï¼‰
        function updateSpeechBubble() {
            const now = performance.now();

            // å¦‚æœç›®å‰æ²’æœ‰æ°£æ³¡æˆ–æ™‚é–“åˆ°äº†ï¼Œå˜—è©¦åˆ‡æ›åˆ°ä¸‹ä¸€å€‹
            if (!activeBubblePerson || now > bubbleVisibleUntil) {
                if (now - lastBubbleSwitch < bubbleInterval) {
                    // é‚„æ²’åˆ°ä¸‹ä¸€æ¬¡é¡¯ç¤ºæ™‚é–“ï¼Œéš±è—æ°£æ³¡
                    bubble.style.opacity = '0';
                    activeBubblePerson = null;
                    return;
                }

                const candidates = people.filter(p => Array.isArray(p.userData.messages) && p.userData.messages.length > 0);
                if (candidates.length === 0) {
                    bubble.style.opacity = '0';
                    activeBubblePerson = null;
                    return;
                }

                const person = candidates[Math.floor(Math.random() * candidates.length)];
                const msgs = person.userData.messages;
                const msg = msgs[Math.floor(Math.random() * msgs.length)];

                activeBubblePerson = person;
                bubble.textContent = msg;
                bubbleVisibleUntil = now + bubbleDuration;
                lastBubbleSwitch = now;
                bubble.style.opacity = '1';
            }

            // å¦‚æœæœ‰æ­£åœ¨é¡¯ç¤ºçš„æ°£æ³¡ï¼Œæ›´æ–°å…¶è¢å¹•åº§æ¨™
            if (activeBubblePerson) {
                const worldPos = new THREE.Vector3();
                activeBubblePerson.getWorldPosition(worldPos);
                worldPos.y += 2.4; // æŠŠæ°£æ³¡ç§»åˆ°é ­é ‚ä¸Šæ–¹ä¸€é»

                const projected = worldPos.clone().project(camera);
                const x = (projected.x * 0.5 + 0.5) * window.innerWidth;
                const y = (-projected.y * 0.5 + 0.5) * window.innerHeight;

                bubble.style.left = `${x}px`;
                bubble.style.top = `${y - 20}px`;
            }
        }

        // å‹•ç•«å¾ªç’°
        function animate() {
            requestAnimationFrame(animate);

            // å¹³æ»‘æ—‹è½‰ç›¸æ©Ÿï¼ˆä½¿ç”¨å—é™åˆ¶çš„ cameraRadiusï¼‰
            const radius = cameraRadius;
            camera.position.x = radius * Math.sin(targetRotationY) * Math.cos(targetRotationX);
            camera.position.y = radius * Math.sin(targetRotationX) + 8;
            camera.position.z = radius * Math.cos(targetRotationY) * Math.cos(targetRotationX);
            camera.lookAt(0, 1, 0);

            // æ›´æ–°çœ¼ç›
            updateEyes();

            // æ›´æ–°å°è©±æ°£æ³¡
            updateSpeechBubble();

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>


