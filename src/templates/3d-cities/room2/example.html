<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js æ¨‚é«˜é¢¨æ ¼æœƒè­°å ´æ™¯</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: #f0f0f0;
        }

        canvas {
            display: block;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #333;
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        #info h3 {
            margin: 0 0 10px 0;
            color: #1a73e8;
        }
    </style>
</head>
<body>
    <div id="info">
        <h3>ğŸ§± æ¨‚é«˜æœƒè­°å ´æ™¯</h3>
        <p>æ‹–æ›³æ»‘é¼ æ—‹è½‰è¦–è§’</p>
        <p>æ»¾è¼ªç¸®æ”¾</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // å ´æ™¯è¨­ç½®
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);

        // ç›¸æ©Ÿ
        const camera = new THREE.PerspectiveCamera(
            45,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(0, 8, 15);
        camera.lookAt(0, 0, 0);

        // æ¸²æŸ“å™¨
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // å…‰æº
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -10;
        directionalLight.shadow.camera.right = 10;
        directionalLight.shadow.camera.top = 10;
        directionalLight.shadow.camera.bottom = -10;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // åœ°æ¿
        const floorGeometry = new THREE.PlaneGeometry(30, 30);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xe0e0e0,
            roughness: 0.8,
            metalness: 0.2
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = -0.5;
        floor.receiveShadow = true;
        scene.add(floor);

        // å‰µå»ºæœƒè­°æ¡Œ
        function createTable() {
            const table = new THREE.Group();

            // æ¡Œé¢
            const topGeometry = new THREE.BoxGeometry(6, 0.2, 4);
            const topMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffffff,
                roughness: 0.3,
                metalness: 0.1
            });
            const top = new THREE.Mesh(topGeometry, topMaterial);
            top.position.y = 1;
            top.castShadow = true;
            top.receiveShadow = true;
            table.add(top);

            // æ¡Œè…³
            const legGeometry = new THREE.BoxGeometry(0.15, 1, 0.15);
            const legMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xcccccc,
                roughness: 0.5
            });

            const legPositions = [
                [-2.5, 0.5, -1.5],
                [2.5, 0.5, -1.5],
                [-2.5, 0.5, 1.5],
                [2.5, 0.5, 1.5]
            ];

            legPositions.forEach(pos => {
                const leg = new THREE.Mesh(legGeometry, legMaterial);
                leg.position.set(...pos);
                leg.castShadow = true;
                table.add(leg);
            });

            // æ¡Œä¸Šç‰©å“ - ç­†è¨˜å‹é›»è…¦
            const laptopBase = new THREE.BoxGeometry(0.6, 0.05, 0.4);
            const laptopScreen = new THREE.BoxGeometry(0.6, 0.5, 0.05);
            const laptopMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
            
            const laptop = new THREE.Group();
            const base = new THREE.Mesh(laptopBase, laptopMaterial);
            base.position.y = 1.15;
            const screen = new THREE.Mesh(laptopScreen, laptopMaterial);
            screen.position.set(0, 1.4, -0.15);
            screen.rotation.x = -0.3;
            laptop.add(base, screen);
            laptop.position.set(-1.5, 0, 0);
            table.add(laptop);

            // æ–‡ä»¶
            const docGeometry = new THREE.BoxGeometry(0.3, 0.02, 0.4);
            const docMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff });
            const document = new THREE.Mesh(docGeometry, docMaterial);
            document.position.set(1.5, 1.12, 0.5);
            table.add(document);

            // æ‰‹æ©Ÿ
            const phoneGeometry = new THREE.BoxGeometry(0.15, 0.02, 0.25);
            const phoneMaterial = new THREE.MeshStandardMaterial({ color: 0x222222 });
            const phone = new THREE.Mesh(phoneGeometry, phoneMaterial);
            phone.position.set(0.8, 1.12, -0.8);
            table.add(phone);

            return table;
        }

        // å‰µå»ºæ¨‚é«˜äººç‰©
        // expression: 'neutral' | 'smile' | 'sad' | 'surprised'
        function createLegoPerson(bodyColor, hairColor, expression = 'neutral') {
            const person = new THREE.Group();

            // èº«é«”
            const bodyGeometry = new THREE.BoxGeometry(0.8, 1.2, 0.6);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: bodyColor,
                roughness: 0.4
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.6;
            body.castShadow = true;
            person.add(body);

            // é ­éƒ¨
            const headGeometry = new THREE.BoxGeometry(0.7, 0.8, 0.7);
            const headMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffd700,
                roughness: 0.3
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.6;
            head.castShadow = true;
            person.add(head);

            // é ­é«®
            const hairGeometry = new THREE.BoxGeometry(0.72, 0.3, 0.72);
            const hairMaterial = new THREE.MeshStandardMaterial({ 
                color: hairColor,
                roughness: 0.6
            });
            const hair = new THREE.Mesh(hairGeometry, hairMaterial);
            hair.position.y = 2.05;
            hair.castShadow = true;
            person.add(hair);

            // çœ¼ç›å®¹å™¨
            const eyesGroup = new THREE.Group();
            eyesGroup.position.set(0, 1.6, 0.36);

            // å·¦çœ¼
            const leftEye = createEye();
            leftEye.position.x = -0.2;
            eyesGroup.add(leftEye);

            // å³çœ¼
            const rightEye = createEye();
            rightEye.position.x = 0.2;
            eyesGroup.add(rightEye);

            person.add(eyesGroup);
            person.userData.eyes = [leftEye, rightEye];

            // å˜´å·´ï¼ˆè¡¨æƒ…ï¼‰
            let mouth;
            if (expression === 'surprised') {
                // é©šè¨ï¼šåœ“å½¢å˜´å·´
                const mouthGeometry = new THREE.CircleGeometry(0.09, 24);
                const mouthMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x000000,
                    side: THREE.DoubleSide
                });
                mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
                mouth.position.set(0, 1.35, 0.37);
            } else {
                // å…¶ä»–ï¼šé•·æ¢å˜´
                const mouthGeometry = new THREE.BoxGeometry(
                    expression === 'smile' ? 0.35 : 0.25,
                    0.05,
                    0.05
                );
                const mouthMaterial = new THREE.MeshStandardMaterial({ 
                    color: expression === 'smile' ? 0xcc0000 : 0x000000 
                });
                mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
                mouth.position.set(
                    0, 
                    expression === 'sad' ? 1.47 : 1.4, 
                    0.36
                );
            }
            person.add(mouth);

            // æ‰‹è‡‚
            const armGeometry = new THREE.BoxGeometry(0.2, 0.8, 0.2);
            const armMaterial = new THREE.MeshStandardMaterial({ 
                color: bodyColor,
                roughness: 0.4
            });

            const leftArm = new THREE.Mesh(armGeometry, armMaterial);
            leftArm.position.set(-0.5, 0.8, 0);
            leftArm.rotation.z = 0.3;
            leftArm.castShadow = true;
            person.add(leftArm);

            const rightArm = new THREE.Mesh(armGeometry, armMaterial);
            rightArm.position.set(0.5, 0.8, 0);
            rightArm.rotation.z = -0.3;
            rightArm.castShadow = true;
            person.add(rightArm);

            return person;
        }

        // å‰µå»ºçœ¼ç›
        function createEye() {
            const eyeGroup = new THREE.Group();

            // çœ¼ç™½
            const whiteGeometry = new THREE.CircleGeometry(0.12, 16);
            const whiteMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffffff,
                side: THREE.DoubleSide
            });
            const white = new THREE.Mesh(whiteGeometry, whiteMaterial);
            eyeGroup.add(white);

            // çœ¼ç ï¼ˆå¯ç§»å‹•ï¼‰
            const pupilGeometry = new THREE.CircleGeometry(0.05, 16);
            const pupilMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x000000,
                side: THREE.DoubleSide
            });
            const pupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
            pupil.position.z = 0.01;
            eyeGroup.add(pupil);

            eyeGroup.userData.pupil = pupil;

            return eyeGroup;
        }

        // æ·»åŠ æœƒè­°æ¡Œ
        const table = createTable();
        scene.add(table);

        // æ·»åŠ äººç‰©
        const people = [];
        const personConfigs = [
            // æ­£é¢ä¸‰äºº
            { pos: [-3, 0, -3], rot: 0.5, body: 0x2c5f2d, hair: 0x654321, expression: 'smile' },
            { pos: [0, 0, -3], rot: 0, body: 0x1e3a5f, hair: 0xffd700, expression: 'surprised' },
            { pos: [3, 0, -3], rot: -0.5, body: 0x1a1a4e, hair: 0x8b4513, expression: 'neutral' },
            // èƒŒé¢ä¸‰äºº
            { pos: [-3, 0, 3], rot: 2.6, body: 0x1a1a4e, hair: 0x8b4513, expression: 'sad' },
            { pos: [0, 0, 3], rot: Math.PI, body: 0x2c5f2d, hair: 0xffa500, expression: 'smile' },
            { pos: [3, 0, 3], rot: -2.6, body: 0x1e3a5f, hair: 0x654321, expression: 'neutral' }
        ];

        personConfigs.forEach(config => {
            const person = createLegoPerson(config.body, config.hair, config.expression);
            person.position.set(...config.pos);
            person.rotation.y = config.rot;
            scene.add(person);
            people.push(person);
        });

        // æ»‘é¼ æ§åˆ¶
        let mouseX = 0;
        let mouseY = 0;
        let targetRotationX = 0;
        let targetRotationY = 0;
        let isMouseDown = false;

        // ç›¸æ©Ÿç¸®æ”¾ï¼ˆè·é›¢ï¼‰æ§åˆ¶
        let cameraRadius = camera.position.length();   // ç›®å‰ç›¸æ©Ÿåˆ°åŸé»çš„è·é›¢
        const minRadius = 10;  // æœ€é è¿‘çš„è·é›¢ï¼ˆä½ å¯ä»¥èª¿æ•´ï¼‰
        const maxRadius = 22;  // æœ€é çš„è·é›¢ï¼ˆä½ å¯ä»¥èª¿æ•´ï¼‰

        document.addEventListener('mousemove', (event) => {
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(event.clientY / window.innerHeight) * 2 + 1;

            // å¦‚æœæ»‘é¼ æŒ‰ä¸‹ï¼Œæ—‹è½‰ç›¸æ©Ÿ
            if (isMouseDown) {
                targetRotationY += event.movementX * 0.005;
                targetRotationX += event.movementY * 0.005;
                targetRotationX = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, targetRotationX));
            }
        });

        document.addEventListener('mousedown', () => {
            isMouseDown = true;
        });

        document.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        // æ»¾è¼ªç¸®æ”¾ï¼ˆé™åˆ¶åœ¨æŒ‡å®šè·é›¢ç¯„åœï¼‰
        document.addEventListener('wheel', (event) => {
            event.preventDefault();

            // deltaY > 0 æ»¾è¼ªå¾€ä¸‹ï¼ˆæ‹‰é ï¼‰ï¼ŒdeltaY < 0 æ»¾è¼ªå¾€ä¸Šï¼ˆæ‹‰è¿‘ï¼‰
            cameraRadius += event.deltaY * 0.02;
            cameraRadius = Math.max(minRadius, Math.min(maxRadius, cameraRadius));
        }, { passive: false });

        // è§¸æ§æ”¯æ´
        let touchStartX = 0;
        let touchStartY = 0;

        document.addEventListener('touchstart', (event) => {
            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;
        });

        document.addEventListener('touchmove', (event) => {
            const touch = event.touches[0];
            mouseX = (touch.clientX / window.innerWidth) * 2 - 1;
            mouseY = -(touch.clientY / window.innerHeight) * 2 + 1;

            const deltaX = touch.clientX - touchStartX;
            const deltaY = touch.clientY - touchStartY;

            targetRotationY += deltaX * 0.005;
            targetRotationX += deltaY * 0.005;
            targetRotationX = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, targetRotationX));

            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
        });

        // éŸ¿æ‡‰å¼
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // æ›´æ–°çœ¼ç›ä½ç½®
        function updateEyes() {
            // å‰µå»ºä¸€å€‹è™›æ“¬çš„æ»‘é¼ ä½ç½®é»
            const vector = new THREE.Vector3(mouseX, mouseY, 0.5);
            vector.unproject(camera);
            
            const dir = vector.sub(camera.position).normalize();
            const distance = -camera.position.y / dir.y;
            const pos = camera.position.clone().add(dir.multiplyScalar(distance));

            people.forEach(person => {
                const eyes = person.userData.eyes;
                if (eyes) {
                    eyes.forEach(eye => {
                        const pupil = eye.userData.pupil;
                        if (pupil) {
                            // è¨ˆç®—çœ¼ç›çœ‹å‘æ»‘é¼ çš„æ–¹å‘
                            const eyeWorldPos = new THREE.Vector3();
                            eye.getWorldPosition(eyeWorldPos);

                            const lookDir = new THREE.Vector3()
                                .subVectors(pos, eyeWorldPos)
                                .normalize();

                            // å°‡æ–¹å‘è½‰æ›ç‚ºçœ¼ç›çš„å±€éƒ¨åæ¨™
                            const localDir = eye.worldToLocal(lookDir.clone().add(eyeWorldPos))
                                .sub(eye.worldToLocal(eyeWorldPos.clone()));

                            // é™åˆ¶ç³å­”ç§»å‹•ç¯„åœ
                            const maxDistance = 0.06;
                            const distance = Math.min(maxDistance, localDir.length());
                            localDir.normalize().multiplyScalar(distance);

                            pupil.position.x = localDir.x;
                            pupil.position.y = localDir.y;
                        }
                    });
                }
            });
        }

        // å‹•ç•«å¾ªç’°
        function animate() {
            requestAnimationFrame(animate);

            // å¹³æ»‘æ—‹è½‰ç›¸æ©Ÿï¼ˆä½¿ç”¨å—é™åˆ¶çš„ cameraRadiusï¼‰
            const radius = cameraRadius;
            camera.position.x = radius * Math.sin(targetRotationY) * Math.cos(targetRotationX);
            camera.position.y = radius * Math.sin(targetRotationX) + 8;
            camera.position.z = radius * Math.cos(targetRotationY) * Math.cos(targetRotationX);
            camera.lookAt(0, 1, 0);

            // æ›´æ–°çœ¼ç›
            updateEyes();

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>